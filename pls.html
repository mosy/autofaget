<h!DOCTYPE html>
<html>
	<head>
    <meta charset="UTF-8">
    <title>HTML5 Navigation Bar Example - Example 1</title>
    <link href="style3.css" rel="stylesheet"/>
	</head>
	<body>

<nav>
    <ul>
        <li>
            <a href="index.html">Home</a>
        </li>
        <li>
            <a href="styringsteknikk.html">Styringsteknikk</a>
            <ul>
                <li><a href="pls.html">PLS</a></li>
                <li><a href="analog.html">Analog</a></li>
            </ul>
        </li>
        <li>
            <a href="oppgaver.html">Oppgaver</a>
        </li>
    </ul>
</nav>
		Denne siden er basert på Tony R. Kuphaldts flotte arbied på https://www.ibiblio.org/kuphaldt/socratic/sinst/  <br>
		Noe er oversatt til norsk, enkelte emner er lagt til og reseten er på orinalspråket.<br> 

<UL CLASS="ChildLinks">
<LI><A ID="tex2html66"
  HREF="pls.html#SECTION00110000000000000000">PLS eksempler</A>
<LI><A ID="tex2html67"
  HREF="pls.html#SECTION00120000000000000000">Inngangs- og utgangs tilkoblinger IO-er  </A>
<UL>
<LI><A ID="tex2html68"
  HREF="pls.html#SECTION00121000000000000000">Digitale IO-er</A>
<LI><A ID="tex2html69"
  HREF="pls.html#SECTION00122000000000000000">Analog I/O</A>
<LI><A ID="tex2html70"
  HREF="pls.html#SECTION00123000000000000000">Network I/O</A>
</UL>
<BR>
<LI><A ID="tex2html71"
  HREF="pls.html#SECTION00130000000000000000">.</A>
<UL>
<LI><A ID="tex2html72"
  HREF="pls.html#SECTION00131000000000000000">Sammenhengen mellom IO-status og virtuelle brytere</A>
<LI><A ID="tex2html73"
  HREF="pls.html#SECTION00132000000000000000">Memory maps and I/O addressing</A>
</UL>
<BR>
<LI><A ID="tex2html74"
  HREF="pls.html#SECTION00140000000000000000">Ladder Diagram (LD) programming</A>
<UL>
<LI><A ID="tex2html75"
  HREF="pls.html#SECTION00141000000000000000">Contacts and coils</A>
<LI><A ID="tex2html76"
  HREF="pls.html#SECTION00142000000000000000">Counters</A>
<LI><A ID="tex2html77"
  HREF="pls.html#SECTION00143000000000000000">Timers</A>
<LI><A ID="tex2html78"
  HREF="pls.html#SECTION00144000000000000000">Data comparison instructions</A>
<LI><A ID="tex2html79"
  HREF="pls.html#SECTION00145000000000000000">Math instructions</A>
<LI><A ID="tex2html80"
  HREF="pls.html#SECTION00146000000000000000">Sequencers</A>
<UL>
<LI><A ID="tex2html81"
  HREF="pls.html#SECTION00146100000000000000">Koyo &ldquo;drum&rdquo; instructions</A>
<LI><A ID="tex2html82"
  HREF="pls.html#SECTION00146200000000000000">Allen-Bradley sequencer instructions</A>
</UL>
<LI><A ID="tex2html83"
  HREF="pls.html#SECTION00147000000000000000">PID regulator i PLS programmer</A>
</UL>
<BR>
<LI><A ID="tex2html84"
  HREF="pls.html#SECTION00150000000000000000">Structured Text (ST) programming</A>
<LI><A ID="tex2html85"
  HREF="pls.html#SECTION00160000000000000000">Instruction List (IL) programming</A>
<LI><A ID="tex2html86"
  HREF="pls.html#SECTION00170000000000000000">Function Block Diagram (FBD) programming</A>
<LI><A ID="tex2html87"
  HREF="pls.html#SECTION00180000000000000000">Sequential Function Chart (SFC) programmering</A>
<UL>
<LI><A ID="tex2html88"
  HREF="pls.html#SECTION00181000000000000000">Sekvensielt funksjonskart</A>
<UL>
<LI><A ID="tex2html89"
  HREF="pls.html#SECTION00181100000000000000">SFC elementer</A>
<LI><A ID="tex2html90"
  HREF="pls.html#SECTION00181200000000000000">SFC Steg typer. </A>
<LI><A ID="tex2html91"
  HREF="pls.html#SECTION00181300000000000000">SFC transition</A>
<LI><A ID="tex2html92"
  HREF="pls.html#SECTION00181400000000000000">SFC Actions</A>
<UL>
<LI><A ID="tex2html93"
  HREF="pls.html#SECTION00181410000000000000">Oppgave til elever</A>
</UL>
<LI><A ID="tex2html94"
  HREF="pls.html#SECTION00181500000000000000">Alternative og parallelle sekvenser. </A>
</UL>
</UL>
<BR>
<LI><A ID="tex2html95"
  HREF="pls.html#SECTION00190000000000000000">Human-Machine Interfaces</A>
<LI><A ID="tex2html96"
  HREF="pls.html#SECTION001100000000000000000">How to teach yourself PLC programming</A>
<LI><A ID="tex2html97"
  HREF="pls.html#SECTION001110000000000000000">Review of fundamental principles</A>
<LI><A ID="tex2html98"
  HREF="pls.html#SECTION001120000000000000000">References</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A ID="SECTION00100000000000000000">
Programmerbare Logiske Styringer</A>
</H1>

<P>
Alle styresystemer kan deles opp i tre deler: <SPAN  CLASS="textit">inngangsenheter</SPAN> (Sensorer og Følere), <SPAN  CLASS="textit">styreenheter</SPAN>, og <SPAN  CLASS="textit">utgangsenheter</SPAN> (pådragsorganer. Inngangsenhetene føler på hva som skjer i prosessen, styreenheten finner ut hva som skal gjøres med det, og utgangsenhetene manipulerer prosessen til ønsket resultat. 

<P>
En <SPAN  CLASS="textit">programmerbar logisk styring</SPAN> eller en PLS er en universal styringsenhet. Den kan brukes til mange ulike typer styringsoppgaver. Det at den er programmerbar gjør den nyttig for bruken som kan  tilpasse den til akkurat sitt behov. En PID sløyferegulator er et eksempel på en spesialbygget styrefunksjon som bare kan brukes som en sløyferegulator. 
<A NAME="31"></A> <A NAME="32"></A>

<P>
PLS-er ble i sin tid lansert som en erstatning for relestyringer. I systemer for styring av/på styring av motorer og andre boolske utganger fikk en mindre systemfeil og lengre levetid. At PLS-en er omprogrammerbar gjorde også at det var lettere å implementere forandringer en med relestyringer. For å få ny funksjon med relestyringer  er det nødvendig å koble om. Da PLS-er er som datamaskiner ble det også mulig å koble de sammen i <SPAN  CLASS="textit">nettverk</SPAN>, noe som muliggjør overvåkning fra operatørstasjoner på fjerne lokasjoner og av flere stasjoner. 

<P>
At PLS-en var ment å overta for relestyringer er lett å se når en bruker det mest valige progarmeringsspråket for PLS-er <SPAN  CLASS="textit">Ladeder Diagram</SPAN>. PLS programmer skrevet i ladder diagram ligner på styrestrømsskjemaer for elektriske koblinger. I Norge er det valing at disse er horisontale. Slik at vi må snu de 90<SPAN CLASS="MATH"><IMG STYLE="height: 1.74ex; vertical-align: -0.10ex; " SRC="pls/img1.svg"
 ALT="$^{\circ}$"></SPAN> for å kunne se de på samme måte. Når en programmerer i ladder "tegner" styrestrømsskjema (med amerikanske symboler). Denne måten å programmere på ble utviklet for å gjøre det enkelt for industielektriekkere å tilpasse seg den nye teknologien. Ladder diagram har klare begrensninger som et programmeringsspråk, men det er lett å lære og diagnostisere. Dette gjør at det fremdeles brukes mye.   <A NAME="36"></A>

<P>
Typisk utstyr som tilkobles en PLS er trykkbyrtere, prosessbrytere, sensorer, analoge transmittere (4-20mA), thermoelementer, termistorer og strekklapper. Til en PLS sine utganger kobles lyx, solenoider, reler, motorstyringer, analoge pådragsorganer og buzzere. PLS-en ble originalt utviklet for å styre digitale (av/på) signaler så som transportbånd, batch sekvenser og monteringslinjer, kan moderne PLS-er like gjerne behandle analogesignaler. Nå kan en PLS like gjerne styre en PID sløyfe som et transportbånd. <A NAME="37"></A>

<P>

<H1><A ID="SECTION00110000000000000000">
PLS eksempler</A>
</H1>

<P>
En PLS er i prinsippet ikke noe annet en en spesialbygget industridatamaskin. Det vil si at den er bygget for å tåle tøffere omgivelser. De har også et operativsystem som er langt mer politlig. PLS-er har som regel ikke HDD, kjølevifter eller andre beveglige deler. Dette er et designvalg som skal gjøre PLS-en mer robust i utsatte industrielle miljøer. Typiske ellementer som en finner i industrielle miljøer er: ekstreme temperaturer, vibarsjoner, luftfuktighet og parikler (strøv, fibre og/eller ulike gasser.).

<P>
Store PLS systemer består av et modulsystem. Modulene kan være IO-moduler, kommunikasjonsmoduler, sikkerhets-PLS-er. Slike systemer er fleksible og kan tilpasses etter behov. De har også den fordelen enkeltfeil kan fikses med å bytten en modul og ikke hele systemet. <A NAME="39"></A>

<P>
Mindre PLS systemer består av en enhet, som inneholder alle funksjoner: CPU, I/O, kommunikasjon. Et slikt system et typisk billigere men er begrenset i I/O kapasitet, og hele enheten må byttes ved en feil. 

<P>
<P>
I bildene som følger vises flere eksempler på PLS systemer fra industrien, noen store systemer og noen mindre systemer. Disse bildene viser på ingen måte hele utvalget av PLS som finnes, men er  et representativt utvalg (for USA) av vanlige PLS merker brukt i industrien (2010)

<P>

<P>
Det første bildet er av en Siemens (Texas Instruments) 505 serie PLS. Den er installert i styreskap til et vannrenseanlegg. Dette er et eksempel på en modulær pls, med individuelle: prosessor, I/O og kommunikkasjonsmoduler som plugges i et rack. Bildet viser tre rack, to er fylt opp med med kort, det tredje er bare delvis fylt. <A NAME="40"></A> <A NAME="41"></A>

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=16cm]{plc_001.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 35.78ex; vertical-align: -0.10ex; " SRC="pls/img2.svg"
 ALT="$\displaystyle \includegraphics[width=16cm]{plc_001.eps}$">
</DIV><P></P>

<P>
Strømforsyningen og prosessorkortet til hvert av rackene er plassert til venstre, andre kort kan tilkobles resten av plassene. Inngangsenheter som bryere og sensorer kobles ved hjelp av ledninger til terminaler på <SPAN  CLASS="textit">inngangskort</SPAN> og utgangsutstyr som lamper, solenoider, og motorstyringer tilkobles terminalene på <SPAN  CLASS="textit">utgangskort</SPAN>. <A NAME="45"></A> <A NAME="46"></A>

<P>
En av fordelene med en modulær PLS oppbyggning er at I/O kortene kan byttes ut som enønsker, på den måtne kan en få akkurat den I/O konfigurasjonen en ønsker. Det kan f.eks. være at du har et styresytem som skal overvåke mange sensore, da installerer Inngangskort som alle sensorene kan tilkobles. Dersom en ønsker å bytte <SPAN  CLASS="textit">type</SPAN> sensor, f.eks. fra en 24 VDC sesnor til en for 230 VAC, kan en bare bytte ut en av kortene. 

<P>
<P>
Denne PLS-en brukes til å styre rensesekvensen av innløpsfiltrene til et kommunalt anlegg for rensing av avløpsvann. Filtrene løftes opp av elektriske motorer, og grovavfall slik som plastikposror o.l. skrapes av og transporteres til et anlegg for søppelhåndtering. PLS-en holder orden på kjøring opp/ned av filtre, vannivå, trykk systemet og forbikoblinger som er innkoblet av operatører. Ved programmering av et slikt system bentyttes timere, tellere, sekvenser og andre funksjoner for å sørge for kontinuerlig drift av anlegget. 

<P>

<P>
Neste bilde viser en Allen-Bradley (Rockwall) PLC-5 PLS, som styrer en naturgass kompressor. I bilde vises to to enheter med ulike IO-kort. <A NAME="48"></A> <A NAME="49"></A>

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=16cm]{plc_002.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 58.56ex; vertical-align: -0.10ex; " SRC="pls/img3.svg"
 ALT="$\displaystyle \includegraphics[width=16cm]{plc_002.eps}$">
</DIV><P></P>

<P>
Akkurat som den forige PLS-en Siemens 505 er Allen-Bradley PLS-5 modulær og konfigrurerbar. IO-kort kan byttes ut etter ønsker og den kan omprogrammeres etter egne behov. 

<P>
I  dette oppsettet har PLS-en som oppgave å følge med på noen av variablene til gasskompressoren. Når det er nødvendig gjøres justeringer som er nødvendig for å holde systemet produktivt og sikkert. Den automatiske styringen som er mulig med en PLS sørger for sikker og effektiv oppstart, nedstengning og håntering av nødstilfeller. Nettverks og dataloggings kapasiteten til PLS-en sørger for at disse dataene kan sjekkes av egnet personel. I akkurat denne kompressoren overføres data fra staten Washington der kompressoren er, til staten Utah der operatørene sitter. Operatørene i Utah kan følge med på driftsegenskapene til kompressoren og gi nødvendige kommandoer over digitale nettverk.

<P>
<P>
Både Simens (tidligere Texas Instruments) 505 og Allen-Bradley (Rockwell) PLC-5 PLS systemene blir annsett som gammeldagse. De er begge over 20 år gamle. Det er ikke uvanlig å finne foreldete PLS systemer i daglig drift. På grunn av de solide og politlige designet kan de være i drift i flere tiår uten problemer. 

<P>

<P>
En nyere modell fra Allen-Bradley er SLC 500 serien, som også er modulbasert. Kortene til SLC 500 serien er mer kompakte. SLC 500 enheten i dette bildet har 7 kortplasser for CPU og IO-kort. Disse blir nummerert 0 til 6. 

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=16cm]{plc_017.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 43.69ex; vertical-align: -0.10ex; " SRC="pls/img4.svg"
 ALT="$\displaystyle \includegraphics[width=16cm]{plc_017.eps}$">
</DIV><P></P>

<P>
De tre første kortplassene i denne SLC 500 enheten (0,1 og 2) har en CPU, AI og DI kort. På plass 3 og 4 er det plass til reservekort. Modul 5 og 6 er hhv. DO- og AO kort. 

<P>
Kort i slike systemer har typisk led indikatorer som forteller om status til kortet. CPU kortet har indikatorer for "RUN" modus, "FLT"(fault) status, bruk av "Force" for å tvinge variabler av en programmerer under testing og kommunikasjons indikator (RS-232). Hver at de digitale kortene har indikatorer for hvert IO-bit og analogkortene har indikasjon av power.  

<P>

<P>
En ni-korts SLC 500 vises i neste bilde. Denne styrer et vannbehandlingssystem med høy rensningsgrad for biologiske legemiddel produksjon. Som du ser er ikke alle plassene opptatt i dette systemet heller. 

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[height=16cm]{plc_018.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 87.98ex; vertical-align: -0.10ex; " SRC="pls/img5.svg"
 ALT="$\displaystyle \includegraphics[height=16cm]{plc_018.eps}$">
</DIV><P></P>

<P>
Noen av inngangene til denne PLS-en er vannivåbrytere, trykkbrytere, flowmålere ledningsevnemålere (for å måle renheten av vannet, jo renere vannet er jo mindre leder det.) Utgangene til PLS-en styrer start og stopp av pumper og  ventiler for kontrollere vennrensing og lagring. 

<P>

<P>
Siemens S7-300 som er en mer moderne PLS fra Siemens. Det er en annen type modulær PLS, istedenfor kort som plugges i brukes individuelle moduler som kan plugges sammen.<A NAME="53"></A>

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=16cm]{plc_003.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 58.56ex; vertical-align: -0.10ex; " SRC="pls/img6.svg"
 ALT="$\displaystyle \includegraphics[width=16cm]{plc_003.eps}$">
</DIV><P></P>

<P>
En moderne PLS produsert av Allen-Bardley er ControlLogix 5000 systemet, som vises i neste bilde. Den brukes til å styre en prosess for produksjon av frokostblanding. Dette systemet følger et mer trasisjonelt system med individuelle kort som plugges i et rack med fast størrelse.<A NAME="55"></A>  <A NAME="56"></A>

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=16cm]{plc_004.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 46.06ex; vertical-align: -0.10ex; " SRC="pls/img7.svg"
 ALT="$\displaystyle \includegraphics[width=16cm]{plc_004.eps}$">
</DIV><P></P>

<P>

<P>
Siemens S7 og Rockwell ControlLogix er eksempler på modulære PLS systemer som kan tilpasses store installasjoner. Det finnes andre PLS-er som er mye billigere. Et eksempel er Koyo Click serien med PLS-er. En prosessormodul med 6 DI(Digiale Innganger) og 6 DO(Digitale Utganger) vises på bildet.(Denne kostet 69 USD i 2010, med gratis programmeringsverktøy.).<A NAME="58"></A>  

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=10cm]{plc_005.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 56.54ex; vertical-align: -0.10ex; " SRC="pls/img8.svg"
 ALT="$\displaystyle \includegraphics[width=10cm]{plc_005.eps}$">
</DIV><P></P>

<P>
Dette er et semi-modulært PLS system, en prosessormodul med et minumum av IO-er, som det er mulig å utvide med flere moduler som plugges i siden, omtrent på samme måte som Siemens S7-300 serien. 

<P>

<P>
Andre semi-modulære PLS-er bruker IO-kort for å utvide grunnmodulen. Koyo DirectLogic DL06 er et eksempel på denne type PLS. Bildet viser DL06 som det settes et kort for termoelementer i en av de 4 ledige plassene.<A NAME="60"></A>

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=10cm]{plc_007.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 36.67ex; vertical-align: -0.10ex; " SRC="pls/img9.svg"
 ALT="$\displaystyle \includegraphics[width=10cm]{plc_007.eps}$">
</DIV><P></P>

<P>
Dette bildet viser en PLS grunnmodul med 20 DI og 16 DO kanaler. Kotet som settes i er for analoge signaler fra thermoelementer. Det kan kobles 4 thermoelementer til kortet.

<P>

<P>
Noen billige kompakt PLS-er har ikke mulighet for utvidelse med IO-moduler.  Denne General Electric Series One PLS (bruk til å overvåke et mini vannkraftverk) er et eksempel på dette. 

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=10cm]{plc_006.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 36.67ex; vertical-align: -0.10ex; " SRC="pls/img10.svg"
 ALT="$\displaystyle \includegraphics[width=10cm]{plc_006.eps}$">
</DIV><P></P>

<P>
Ulempen med et kompakt PLS er at en defekt IO ikke kan byttes ut sepparat. Hele PLS-en må byttes. I et modulært system kan hver IO-modul byttes ved feil. En annen ulempe er at brukeren er låst til IO-konfigurasjonen som PLS har. Det er ingen mulighet for tilpassning til bruken. På grunn av dette brukes som oftest kompakt PLS-er på  mindre automatiserte anlegg der en ikke forventer behov for utvidelse.  

<P>

<H1><A ID="SECTION00120000000000000000">
Inngangs- og utgangs tilkoblinger IO-er  </A>
</H1>

<P>
Alle PLS-er må kunne motta og forstå signaler fra den virklige verden, f.eks. byrtere og enkodere. Den må også kunne kontrollere enheter som solenoider, ventiler og motorer. Dette kalls for PLS-ens IO-kapasitet. En kompakt PLS har en bestemt IO-kapasitet, mens en modulær PLS har mulighet for å konfigurere IO-kapasiteten.<A NAME="64"></A>  

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_075.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 31.55ex; vertical-align: -0.10ex; " SRC="pls/img11.svg"
 ALT="$\displaystyle \includegraphics{plc_075.eps}$">
</DIV><P></P>

<P>
Det er mange fordeler med å bruke IO-moduler istedenfor en kompakt PLS. Den visktigste er at devekte IO-kort kan byttes uten å måtte bytte hele PLS-en. Det er også mulig å velge IO-kort alt etter behovet i styringssystemet. Typisk trenger styringsoppgaver som flytter på "ting" mange digitale inn- og utganger, mens en i prosessanlegg trenger flere analoge inn og -utganger. Noen  PLS-systemer har også muligheten for <SPAN  CLASS="textit">hot-swappable</SPAN> moduler, det vil si at de kan byttes uten å ta strømmen fra PLS-systemet. Vær obs på at dette bare kan gjøres på systemer som er laget for det, ellers kan du ødlegge PLS-systemet.<A NAME="67"></A>  <A NAME="68"></A>

<P>

<P>
Noen PLS-er har mulighet for tilkobling av eksterne moduler uten prosessorer, dette gjør det mulig å utvide IO-kapasiteten . Disse kobles sammen til et digitalt nettverk med en kommunikasjonskabel. Dette gjør at en kan ha stor fysisk avstand mellom PLS og IO-er på et anlegg. Slike eksterne IO-enheter kalles normalt for en RIO (Remote IO) <A NAME="69"></A> <A NAME="70"></A>. 

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_008.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 60.58ex; vertical-align: -0.10ex; " SRC="pls/img12.svg"
 ALT="$\displaystyle \includegraphics{plc_008.eps}$">
</DIV><P></P>

<P>
Et alternativ til et styresystem med remote IO er å koble sammen flere PLS-er. En kan da programmere PLS-ene til å dele på IO-er, for på den måten å utvide IO-kapasiteten. Dette er en dyr metode, men detn gir mulighet for videre drift selv om det skulle være feil på nettverket. 

<P>
<P>
IO-tilkoblinger for en PLS kommer i to ulike kategorier <SPAN  CLASS="textit">digitale</SPAN> og <SPAN  CLASS="textit"> analoge</SPAN> disse beskrives i de neste kaptittelene. 

<P>

<H2><A ID="SECTION00121000000000000000">
Digitale IO-er</A>
</H2>

<P>
Et digitalt singal for en PLS, er et signal som kan ha to tilstander <SPAN  CLASS="textit">av</SPAN> og <SPAN  CLASS="textit">på</SPAN>. Disse bruker datatypen BOOL i internt i PLS-en. Trykkbrytere, temperaturbrytere, trykknappbrytere, endebrytere og nærhetssensorer er eksempler på digitale signalkilder for en PLS. For at PLS-en skal lese signaler fra denne type sensorer må den ha en digitale innganger. Digitale innganger på en PLS vil ha en lysdiode som indikerer om en inngang er aktivert eller ikke. Det vil også være en annen LED som er en del av en optokobler. Optokobleren lager et galvansik skille mellom sensorkretsen og mikroprosessorkretsen inne i PLS-en. Et slikt system gjør at en PLS er mindre følsom fra spenningstransienter. Optokobleren aktiver et bit inn minnet til PLS-en. Dette minnet brukes av PLS programmet til å avgjøre om en sensor er aktivert eller ikke. <A NAME="77"></A> <A NAME="78"></A> 

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_073.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 38.71ex; vertical-align: -0.10ex; " SRC="pls/img13.svg"
 ALT="$\displaystyle \includegraphics{plc_073.eps}$">
</DIV><P></P>

<P>
Det interne koblingskjemaet for en inngangmodul viser de viktigste komponentene for en inngang. Hver inngang har samme kretsen som skriver til hvert sitt bit i PLS-ens minne. Digitale inngangmoduler har vanligvis 4, 8, 16 eller 32 innganger.  

<P>

<P>
Signallamper, magnetventiler og motorstartere er alle eksempler på digitale styringselementer. Omtrent på samme måte som digitale innganger kobler PLS-en seg til digitale styringselementt ved hjelp av digitale utgangsmoduler. Digitale utgangsmoduler bruker ofte samme type galvansik skille som inngangmoduler, ved hjelp av en optokobler. Alternativt brukes også elektromekaniske releer. 

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_074.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 37.16ex; vertical-align: -0.10ex; " SRC="pls/img14.svg"
 ALT="$\displaystyle \includegraphics{plc_074.eps}$">
</DIV><P></P>

<P>
Som ved den digitaleinngangsmodule vises et koblingsskjema en av flere utganger. Hver utgang har sitt tilhørende bit i minnet som vil aktivere utgangen. Digitale ugangsmoduler har typisk 4, 8, 16, eller 32 utganger. 

<P>
<P>

<P>
Et viktig konsept å beherske når en jobber med digitale inn- og utganger er forskjellen mellom <SPAN  CLASS="textit">current-sourcing</SPAN> og <SPAN  CLASS="textit">current-sinking</SPAN>. Begrepene "sourcing" og "sinking" refererer til retningen til strømmen inn eller ut av terminalen for styresignal. En enhet som sender strøm ut av styreterminalen sies å <SPAN  CLASS="textit">sourcing</SPAN>, mens utstrm som tar imont strøm sies å være <SPAN  CLASS="textit">sinking</SPAN>.<A NAME="85"></A>  <A NAME="86"></A>  <A NAME="87"></A>  <A NAME="88"></A>

<P>

<P>
Tegningen nedenfor illustrerer PLS utgang som er current <SPAN  CLASS="textit">sourcing</SPAN> for en lampe som er current<SPAN  CLASS="textit">sinking</SPAN>.

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_009.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 41.81ex; vertical-align: -0.10ex; " SRC="pls/img15.svg"
 ALT="$\displaystyle \includegraphics{plc_009.eps}$">
</DIV><P></P>

<P>

<P>
Om det tilkoblede utstyret polaritetsuavhengig, er det like gylding om en har <SPAN  CLASS="textit">sourcing</SPAN> eller <SPAN  CLASS="textit">sinking</SPAN> DI-modul. Bildet viser et eksempel med en endebryter. 

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_010.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 36.58ex; vertical-align: -0.10ex; " SRC="pls/img16.svg"
 ALT="$\displaystyle \includegraphics{plc_010.eps}$">
</DIV><P></P>

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_011.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 36.58ex; vertical-align: -0.10ex; " SRC="pls/img17.svg"
 ALT="$\displaystyle \includegraphics{plc_011.eps}$">
</DIV><P></P>

<P>
Legg merke til polariteten på fellesterminalen på begge moduelene. Modulen som er <SPAN  CLASS="textit">sinking</SPAN> har fellesterminalen koblet til minus, mens modulen som  er <SPAN  CLASS="textit">sourcing</SPAN> er koblet til +. 

<P>

<P>
Noen digitale sensorer <SPAN  CLASS="textit">har</SPAN> en bestempt polaritet, f.eks. nærhetssensorer med transistorutgang. En <SPAN  CLASS="textit">sourcing</SPAN> nærhetssensor kan bare kobles til en <SPAN  CLASS="textit">sinking</SPAN> PLS inngang, og visa versa.<A NAME="101"></A>  <A NAME="102"></A>  <A NAME="103"></A>  <A NAME="104"></A>

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_012.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 88.06ex; vertical-align: -0.10ex; " SRC="pls/img18.svg"
 ALT="$\displaystyle \includegraphics{plc_012.eps}$">
</DIV><P></P>

<P>
I alle tilfellene sender enheten som er <SPAN  CLASS="textit">sourcing</SPAN> ut strøm fra signalterminalen til <SPAN  CLASS="textit">sinking</SPAN> enheten som mottar signal på sin signalterminal. 

<P>

<P>
Her vises to bilder av en DI module(1746-IB8) til Allen-Bradley modell SLC 500 PLS. På det dene bilder er dekselset lukket. På det andre er dekselet åpen og vi ser terminalene sammen med en forklaring på funksjonen til hver terminal. Her ser vi at modulen har 8 digitale innganger, nummerert fra IN0 til IN7, og to tilkoblinger for COM. Vi ser også at dette er en DC-SINK modul. 

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[height=4in]{plc_013.eps} \hskip 30pt \includegraphics[height=4in]{plc_014.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 55.94ex; vertical-align: -0.10ex; " SRC="pls/img19.svg"
 ALT="$\displaystyle \includegraphics[height=4in]{plc_013.eps} \hskip 30pt \includegraphics[height=4in]{plc_014.eps}$">
</DIV><P></P>

<P>
En standard funksjon som nesten alle digitale innganger har er et indikatorlys som viser når inngangen er aktiv. På 1746-IB8 modulen til Allen-Bradley SLC 500 PLS systemen ser vi disse samlet på toppen av modulen i to rekker. 

<P>
Et bilde av DI terminalene til en annen PLS (Koyo model DL06) viser en annen merking. 

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=16cm]{plc_015.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 42.11ex; vertical-align: -0.10ex; " SRC="pls/img20.svg"
 ALT="$\displaystyle \includegraphics[width=16cm]{plc_015.eps}$">
</DIV><P></P>

<P>
Her er hver utgang gitt et bokstavnummer kombinasjon som starter med Y ellerfult av nummere på utgangen. Det er også C terminaler, dette er fellesterminaler for samlinger på fireutganger på denne PLS-en. Selv som det kan virke litt tungvint å ha flere fellesterminaler, så gjør dette PLS-en mer fleksibler for flere driftsspenninger og det muliggjør bruk av interne styrespenninger fra utstyr. 

<P>
<P>
Elektriske polaritet er ikke noe en trenger å tenke på ved bruk av digitale innganger for AC, siden polariteten snus hver periode uansett. En må likevell tenke på om fellesterminalen skal kobles til nøytral eller en av faselederene. Denne informasjonen vil en finne i leverandør manualen for den aktuelle modulen. 

<P>
Neste bilde viser en digital utgangsmodul for AC fra Allen-Bradly. Her brukes triacer på utgangen istedenfor transistorer som er vanlig for DC type utganger. 

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[height=4in]{plc_021.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 55.94ex; vertical-align: -0.10ex; " SRC="pls/img21.svg"
 ALT="$\displaystyle \includegraphics[height=4in]{plc_021.eps}$">
</DIV><P></P>

<P>
Denne 8 kanals modulen har to sett med TRIACer som  får spenning fra hver sine fellesterminaler VAC1 og VAC2, den andre siden av lasten kobles til motsatt faseleder eller nøytral. 

<P>
<P>
Heldigvis leverer leverandørene manualer som illurtrerer hvordan digitale inn og utganger skal kobles til feltutstyret. Det er viktig at du alltid setter deg inn i disse manualene. 

<P>

<H2><A ID="SECTION00122000000000000000">
Analog I/O</A>
</H2>

<P>
Når PLS-ene kom på markedet på markedet, var prosessorhastigheten og minnet så begrenset at det ikke var mulig å støtte annet en digitale styringsfunksjoner. Derfor ble de også bare laget med digitale IO-er. Moderne PLS-er har nok prosessorkrat og minne til å støtte måling, prossesering og styring av analoge signaler. <A NAME="113"></A>

<P>
En PLS jobber digitalt internt. For å ta imot og sende ut analoge singaler er det nødvendig med en omformer mellom digitale og analoge signaler. I alle analoge inngangmoduler er det en <SPAN  CLASS="textit">ADC</SPAN>, eller <SPAN  CLASS="textit">Analog til Digital Converter</SPAN> som skal konvertere det eletriske signalet på inngangen til et binert tall. Det motsatte trengs på en analog utgangsmodul, der brukes  en , <SPAN  CLASS="textit">DAC</SPAN>, eller <SPAN  CLASS="textit">Digital til Analog Converter</SPAN> som konverterter binære tall til analoge elektriske signaler.  <A NAME="118"></A>  <A NAME="119"></A>  <A NAME="120"></A>  <A NAME="121"></A>

<P>
Analog IO finnes for mange ulike typer analoge signaler, noen som brukes masse er:

<P>

<UL>
<LI>Spenning (0 to 10 volt, 0 to 5 volt)
</LI>
<LI>Strøµ (0 to 20 mA, 4 to 20 mA)
</LI>
<LI>Thermoelement (millivoltage)
</LI>
<LI>RTD (millivoltage)
</LI>
<LI>Strekklapp.  (millivoltage)
</LI>
</UL>

<P>

<P>
Bildene viser to analoge IO-kort til en Allen-Bradley SLC 500. Det er et analogt inngangskort(AI) og et analogt utgangskfort(AO).  Merkelappen i dekselet indikerer hvordan modulene skal kobles. 

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[height=6in]{plc_019.eps} \hskip 30pt \includegraphics[height=6in]{plc_020.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 83.81ex; vertical-align: -0.10ex; " SRC="pls/img22.svg"
 ALT="$\displaystyle \includegraphics[height=6in]{plc_019.eps} \hskip 30pt \includegraphics[height=6in]{plc_020.eps}$">
</DIV><P></P>

<P>

<H2><A ID="SECTION00123000000000000000">
Network I/O</A>
</H2>

<P>
Many different digital network standards exist for PLCs to communicate with, from PLC to PLC and between PLCs and field devices.  One of the earliest digital protocols developed for PLC communication was <SPAN  CLASS="textit">Modbus</SPAN>, originally for the Modicon brand of PLC.  Modbus was adopted by other PLC and industrial device manufacturers as a <SPAN  CLASS="textit">de facto</SPAN> standard<A ID="tex2html1"
  HREF="footnode.html#foot791"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A>, and remains perhaps the most universal digital protocol available for industrial digital devices today. <A NAME="132"></A>  <A NAME="133"></A>

<P>
Another digital network standard developed by a particular manufacturer and later adopted as a <SPAN  CLASS="textit">de facto</SPAN> standard is <SPAN  CLASS="textit">Profibus</SPAN>, originally developed by Siemens.  <A NAME="136"></A>

<P>
For more information on networking standards used in PLC systems, refer to the &ldquo;Digital electronic instrumentation&rdquo; chapter, specifically sections on specific network standards such as Modbus and Profibus.

<P>

<H1><A ID="SECTION00130000000000000000">.</A>

</H1>

<P>
Det kan se ut som alle PLS-er har sin egen standard for programmering, men det finnes en international standard for PLS progarmmering som de fleste PLS produsenter i det minste forsøker å følge. Dette er IEC 61131-3, som vi vil bruke her.<A NAME="138"></A>

<P>
En kan trøste seg med at selv som detaljene fra et PLS programmeringsverktøy til et annet, er prinseppene i det store å hele det samme. Det er mye større forskjelle i generelle programmeringsspråk( som C/C++, BASIC, FORTRAN, Pascal, Java, bl.a. )en mellom prgrammeringsverktøy fra ulike PLS leverandører, på tross av dette behersker programmere flere språk. Tony har programmert mange ulike PLS-er (Allen-Bradley, Siemens, SquareD, Koyo, Fanuc, Moore Products APACA AND QUADLOG og Modicon) med ulike typer av PLS innfor mange av merkene, og han kan fortelle at forskjellene i det store og hele er ubetydlige. Etter å ha lært en type PLS er det enkelt å gå over til en annen PLS. Selv om du programmerer en PLS som ikke følger IEC 61131-3 kan du følge prinsippene i dette kapittelet. De grunnleggende prinsippene er universelle. 

<P>
IEC-61131-3 standarden spesifiserer fem forskjellige programmeringsspråk for industrielle styringer:

<P>

<UL>
<LI>Ladder Diagram (LD)
</LI>
<LI>Structured Text (ST)
</LI>
<LI>Instruction List (IL)
</LI>
<LI>Function Block Diagram (FBD)
</LI>
<LI>Sequential Function Chart (SFC)
</LI>
</UL>

<P>
Ikke alle programmeringsspråk støttes av alle PLS-er, men omtrent alle støtter Ladder Diagram (LD), som vil være fokus i denne boken. 

<P>

<H2><A ID="SECTION00131000000000000000">
Sammenhengen mellom IO-status og virtuelle brytere</A>
</H2>

<P>
Et konsept som krever litt tilvenning når en lærer å programmere PLS er sammenhengen mellom IO-ene og statusen på variabler og andre elementer i programmet. Dette gjelder spesielt for Ladder diagram (LD), der programmet ligner et elektriske skjema. Det er viktig å gjøre den mentale koblingen mellom virklige byrere og sensorer i anlegget og de tenkte byrerene og relespolene en finner i PLS-programmet. 

<P>
En grunnleggende regel en må tenke på når en leser et ladder program er at <SPAN  CLASS="textbf">hver kontakt i programmet aktiveres ved at den leser "1" i det tilhørende minnebit,  og at den deaktiveres når den leser "0" i det tilhørdne minnebit.</SPAN>. For en NO kontakt vil det si at den er lukket nå tilhørdne minnebit er "1" For en NO kontakt vil det si at den er lukket når tilhørende minnebit er "0". Om et bit har tilstanden "0"  vil det si at tilhørdne kontakt er i sin normale posisjon, mens en bitstatus på "1" vil få kontakten til å aktivere og gå i sin aktive tilstand. <A NAME="143"></A>  

<P>
En annen viktig regel når en leser PLS programmer er at programmeringsgrensesnittet tilbyr <SPAN  CLASS="textit">farge merkeing</SPAN> for å markere virtuel status av hvert program element. <SPAN  CLASS="textbf">En farget kontakt(<SPAN ID="cbox146">-<SPAN CLASS="MATH"><IMG STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="pls/img23.svg"
 ALT="$\vert$"></SPAN> <SPAN CLASS="MATH"><IMG STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="pls/img23.svg"
 ALT="$\vert$"></SPAN>-</SPAN>) er <SPAN  CLASS="textit">lukket</SPAN>, mens en ikke farget (-<SPAN CLASS="MATH"><IMG STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="pls/img23.svg"
 ALT="$\vert$"></SPAN> <SPAN CLASS="MATH"><IMG STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="pls/img23.svg"
 ALT="$\vert$"></SPAN>-) er <SPAN  CLASS="textit">åpen</SPAN></SPAN>. Om  bryteren har en skråstrek (-<SPAN CLASS="MATH"><IMG STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="pls/img24.svg"
 ALT="$\vert/\vert$"></SPAN>-) eller ikke (-<SPAN CLASS="MATH"><IMG STYLE="height: 2.51ex; vertical-align: -0.68ex; " SRC="pls/img25.svg"
 ALT="$\vert\:\vert$"></SPAN>-) marker hvilken normale status brytern har, så marker farge om den er lukket eller ikke.

<P>
Tabellen nedenfor viser hvordan to typer kontakter et PLS ladder program forholder seg til ulike bitstatuser. Det brukes rød for å vise når en virtuell kontakt leder. 

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_065.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 26.52ex; vertical-align: -0.10ex; " SRC="pls/img26.svg"
 ALT="$\displaystyle \includegraphics{plc_065.eps}$">
</DIV><P></P>

<P>
Akkurat som en trykkbryter aktiveres av høyt trykk, og en nivåbryter aktiveres av høyt nivå, og en temperaturbyter aktiveres av høy temperatur, så vil en PLS sine virtuelle brytere aktiveres av et høyt <SPAN  CLASS="textit">bit</SPAN> status. Med en bryte sin <SPAN  CLASS="textit">aktiverte</SPAN> tilstand mener vi det motsatte av den <SPAN  CLASS="textit">normale</SPAN> tilstand.

<P>

<P>
Illustrasjonen nedenfor viser en kompakt PLS med to av de digitale inngangene aktivert, noe som gjør at de tilhørende bit i inngangsregisteret er høye (TRUE eller "1"). De kontaktene som er farget i PLS programmeringsverktøyet viser virtuelle kontakter som vil sende <SPAN  CLASS="textit">signalet</SPAN> videre ved de statuser som vises i  inngangsregisteret.

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_064.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 64.06ex; vertical-align: -0.10ex; " SRC="pls/img27.svg"
 ALT="$\displaystyle \includegraphics{plc_064.eps}$">
</DIV><P></P>

<P>
<SPAN  CLASS="textbf">Husk</SPAN> at en farget kontakt er en <SPAN  CLASS="textit">lukket</SPAN> kontakt. De kontaktene som er farget er enten NC kontakter med "0" bit status, eller NO kontakter med "1" bit status. Det er kombinasjonen av bit status og type kontakt (NO/NC) som avgjør om den virtuelle kontakten vil  være åpen (ikke farget) eller lukket (farget). 

<P>

<P>
Min erfaring som lærer er at hovedproblemet elever har med å forstå PLS ladderprogrammer, er at de prøver å simplifisere ved å relatere vituelle kontakter i pls programmet med kontakter ute i anlegget. Det som skjer er at kontakter i anlegget sender spenning til inngange <SPAN  CLASS="textit">som igjen <SPAN ID="txt157">styrer</SPAN></SPAN> status til den virtuelle kontakten i PLS programmet. Typiske feil som elever gjøre er:

<P>

<UL>
<LI>Elever tror kontakten i PLS programmet må være av samme type (NO/NC) som tilhørende bryter i anlegget
</LI>
<LI>Elever tror at fargemerkingen av en kontakt er det samme som status på tilhørende inngang. 
</LI>
<LI>Elever tror en lukket kontakt i anlegget må resultere i en lukket kontakt i PLS programmet.
</LI>
</UL>

<P>
Oppsummering av grunnleggende regler når en leser et PLS ladder program:

<P>

<UL>
<LI><SPAN  CLASS="textbf">Hvert inngangsbit i PLS-en sitt minne vil være "1" når dens tilhørende inngang aktiveres</SPAN>
</LI>
<LI><SPAN  CLASS="textbf">Hver virtuelle kontakt som vises i programmet<SPAN  CLASS="textit">aktiveres</SPAN> når den leser "1" i tilhørende bit i inngangsregisteret, og vil være i normaltilstand når den leser "0" i tilhørende minnebit</SPAN>
</LI>
<LI><SPAN  CLASS="textbf">En farget kontakt er <SPAN  CLASS="textit">lukket</SPAN> (sender videre signal i PLS programmet), mens en ikke farget kontakt er <SPAN  CLASS="textit">åpen</SPAN> (blokkerer signal i PLS programmet)</SPAN>
</LI>
</UL>

<P>
Dette er meget viktige regler å ha klart for seg  når en skal forstå PLS ladder programmer. 

<P>
<P>
Fargemerking av en <SPAN  CLASS="textit">coil</SPAN> [&mdash;( )] i ladder PLS programmer følger lignende regler. En coil vil være "på" (farget) når alle brytere og funksjoner før den er farget. En coil som er farget vil skrive "1" til tilhørende bit i minnet, mens en coil som ikke er farget sender  en "0" til det tilhørende minnebit. Om disse minnebitene har en kobling mot fysike digitale utganger vil disse bli aktivert

<P>

<P>
For å se nærmere på disse grunnleggende konseptene, se nærmere på en PLS styring for å aktivere et varsellys for høyt trykk i en væsketank. PLSen sin oppgave er å aktivere varsellyset når trykket i tanken overstiger 18 BAR, og holde det aktivt selv om det faller under 18 BAR igjen. På denne måten vil operatørene varsles med både nåværende feil og feil som har vært.

<P>
230 Volt AC forsyningen (L1 og L2) forsyner PLS-en med driftsspenning, den gir også signalpotensial for inngangsbyterene og driftsspenning for varsellampen. To brytere er koblet til inngangen på denne PLS-en: en NO trykknappbryter, som virker som resetbryter for alarmen, og en NO trykkbryter som gir signal om høyt trykk i prosesstanken.

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_055.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 66.58ex; vertical-align: -0.10ex; " SRC="pls/img28.svg"
 ALT="$\displaystyle \includegraphics{plc_055.eps}$">
</DIV><P></P>

<P>
Resetknappen kobles til den digitale inngangen <SPAN  CLASS="texttt">X1</SPAN> på PLS-en, mens trykkbryteren kobles til den digitale inngangen <SPAN  CLASS="texttt">X4</SPAN>. Varsellampen kobles til den digitale utgangen <SPAN  CLASS="texttt">Y5</SPAN>. Røde indikatorlys ved siden av hver inngang indikerer status den den respektive inngangen. Rød bakgrunn på brytere i PLS programmet representerer en bryter som sender signalet videre. 

<P>
Når ingen trykker på resetkanppen vil den være i sin normale posisjon, som for denne bryteren er åpen (NO). Det samme gjelder for trykkbyteren. Når trykket er under 18 BAR vil bryteren være i sin normale posisjon som er åpen (NO). Siden ingen av bryterne leder, vil heller ingen av de digitale inngangene på PLS-en være aktive. Dette betyr at de virtuelle bryterne i PLS programmet også vil være i sin normal posisjon. Da vil alle NO brytere stoppe signalet og alle NC brytere sende signalet videre. Derfor ser en på bildet at <SPAN  CLASS="texttt">X4</SPAN> og <SPAN  CLASS="texttt">Y5</SPAN> ikke er merket med rødt, mens <SPAN  CLASS="texttt">X1</SPAN> er merket rødt. Brytere som er merket rødt betyr at de sender de sender signalet videre og utganger som er merket rødt beytr at de er aktive.

<P>
<P>

<P>
Om trykket i prosesstanken overstiger 18 BAR aktiveres trykkbrteren og NO-kontaktsettet lukkes. 

<P>
If the process vessel experiences a high pressure (<SPAN CLASS="MATH"><IMG STYLE="height: 1.47ex; vertical-align: -0.16ex; " SRC="pls/img29.svg"
 ALT="$&gt;$"></SPAN> 270 PSI), the pressure switch will actuate, closing its normally-open contact.  This will energize input <SPAN  CLASS="texttt">X4</SPAN> on the PLC, which will &ldquo;close&rdquo; the virtual contact <SPAN  CLASS="texttt">X4</SPAN> in the ladder program.  This sends virtual power to the virtual &ldquo;coil&rdquo; <SPAN  CLASS="texttt">Y5</SPAN>, which in turn latches itself on through virtual contact <SPAN  CLASS="texttt">Y5</SPAN><A ID="tex2html2"
  HREF="footnode.html#foot796"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN></SUP></A> and also energizes the real discrete output <SPAN  CLASS="texttt">Y5</SPAN> to energize the warning lamp:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_056.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 67.55ex; vertical-align: -0.10ex; " SRC="pls/img30.svg"
 ALT="$\displaystyle \includegraphics{plc_056.eps}$">
</DIV><P></P>

<P>

<P>
If now the process pressure falls below 270 PSI, the pressure switch will return to its normal state (open), thus de-energizing discrete input <SPAN  CLASS="texttt">X4</SPAN> on the PLC.  Because of the latching contact <SPAN  CLASS="texttt">Y5</SPAN> in the PLC's program, however, output <SPAN  CLASS="texttt">Y5</SPAN> remains on to keep the warning lamp in its energized state:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_057.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 67.55ex; vertical-align: -0.10ex; " SRC="pls/img31.svg"
 ALT="$\displaystyle \includegraphics{plc_057.eps}$">
</DIV><P></P>

<P>
Thus, the <SPAN  CLASS="texttt">Y5</SPAN> contact performs a <SPAN  CLASS="textit">seal-in</SPAN> function to keep the <SPAN  CLASS="texttt">Y5</SPAN> bit set (1) even after the high-pressure condition clears.  This is precisely the same concept as the &ldquo;seal-in&rdquo; auxiliary contact on a hard-wired motor starter circuit, where the electromechanical contactor keeps itself energized after the &ldquo;Start&rdquo; pushbutton switch has been released.  <A NAME="190"></A>  <A NAME="191"></A>  <A NAME="192"></A>

<P>

<P>
The only way for a human operator to re-set the warning lamp is to press the pushbutton.  This will have the effect of energizing input <SPAN  CLASS="texttt">X1</SPAN> on the PLC, thus opening virtual contact <SPAN  CLASS="texttt">X1</SPAN> (normally-closed) in the program, thus interrupting virtual power to the virtual coil <SPAN  CLASS="texttt">Y5</SPAN>, thus powering down the warning lamp and un-latching virtual power in the program:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_058.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 67.55ex; vertical-align: -0.10ex; " SRC="pls/img32.svg"
 ALT="$\displaystyle \includegraphics{plc_058.eps}$">
</DIV><P></P>

<P>

<H2><A ID="SECTION00132000000000000000">
Memory maps and I/O addressing</A>
</H2>

<P>
A wise PLC programmer once told me that the first thing any aspiring programmer should learn about the PLC they intend to program is how the digital memory of that PLC is organized.  This is sage advice for any programmer, especially on systems where memory is limited, and/or where I/O has a fixed association with certain locations in the system's memory.  Virtually every microprocessor-based control system comes with a published <SPAN  CLASS="textit">memory map</SPAN> showing the organization of its limited memory: how much is available for certain functions, which addresses are linked to which I/O points, how different locations in memory are to be referenced by the programmer.

<P>
Discrete input and output channels on a PLC correspond to individual <SPAN  CLASS="textit">bits</SPAN> in the PLC's memory array.  Similarly, analog input and output channels on a PLC correspond to multi-bit <SPAN  CLASS="textit">words</SPAN> (contiguous blocks of bits) in the PLC's memory.  The association between I/O points and memory locations is by no means standardized between different PLC manufacturers, or even between different PLC models designed by the same manufacturer.  This makes it difficult to write a general tutorial on PLC addressing, and so my ultimate advice is to consult the engineering references for the PLC system you intend to program.  

<P>
The most common brand of PLC in use in the United States at the time of this writing (2010) is Allen-Bradley (Rockwell), which happens to use a unique form of I/O addressing<A ID="tex2html3"
  HREF="footnode.html#foot797"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN></SUP></A> students tend to find confusing.  For these two reasons (popularity and confusion), I will focus on Allen-Bradley addressing conventions for the bulk of this section.

<P>

<P>
The following table shows a partial memory map for an Allen-Bradley SLC 500 PLC<A ID="tex2html4"
  HREF="footnode.html#foot798"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN></SUP></A>: <A NAME="203"></A>

<P>
<P><!-- MATH
 \begin{displaymath}
\vbox{\offinterlineskip
\halign{\strut
\vrule \quad\hfil # \ \hfil &
\vrule \quad\hfil # \ \hfil & 
\vrule \quad\hfil # \ \hfil \vrule \cr
\noalign{\hrule }
\textbf{File number} & \textbf{File type} & \textbf{Logical address range} \cr
\noalign{\hrule }
0 & Output image & \texttt{O:0} to \texttt{O:30} \cr
\noalign{\hrule }
1 & Input image & \texttt{I:0} to \texttt{I:30} \cr
\noalign{\hrule }
2 & Status & \texttt{S:0} to \texttt{S:}$n$ \cr
\noalign{\hrule }
3 & Binary & \texttt{B3:0} to \texttt{B3:255} \cr
\noalign{\hrule }
4 & Timers & \texttt{T4:0} to \texttt{T4:255} \cr
\noalign{\hrule }
5 & Counters & \texttt{C5:0} to \texttt{C5:255} \cr
\noalign{\hrule }
6 & Control & \texttt{R6:0} to \texttt{R6:255} \cr
\noalign{\hrule }
7 & Integer & \texttt{N7:0} to \texttt{N7:255} \cr
\noalign{\hrule }
8 & Floating-point & \texttt{F8:0} to \texttt{F8:255} \cr
\noalign{\hrule }
9 & Network & \texttt{x9:0} to \texttt{x9:255} \cr
\noalign{\hrule }
10 through 255 & User defined & \texttt{x10:0} to \texttt{x255:255} \cr
\noalign{\hrule }
} % End of \halign 
}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 34.75ex; vertical-align: -0.10ex; " SRC="pls/img33.svg"
 ALT="$\displaystyle \vbox{\offinterlineskip
\halign{\strut
\vrule \quad\hfil  ...">
</DIV><P></P> 
<P>
Note that Allen-Bradley's use of the word &ldquo;file&rdquo; differs from personal computer parlance.  In the SLC 500 controller, a &ldquo;file&rdquo; is a block of random-access memory used to store a particular type of data.  By contrast, a &ldquo;file&rdquo; in a personal computer is a contiguous collection of data bits with collective meaning (e.g. a word processing file or a spreadsheet file), usually stored on the computer's hard disk drive.  Within each of the Allen-Bradley PLC's &ldquo;files&rdquo; are multiple &ldquo;elements,&rdquo; each element consisting of a set of bits (8, 16, 24, or 32) representing data.  Elements are addressed by number following the colon after the file designator, and individual bits within each element addressed by a number following a slash mark.  For example, the first bit (bit 0) of the second element in file 3 (Binary) would be addressed as <SPAN  CLASS="texttt">B3:2/0</SPAN>.  

<P>
In Allen-Bradley PLCs such as the SLC 500 and PLC-5 models, files 0, 1, and 2 are exclusively reserved for discrete outputs, discrete inputs, and status bits, respectively.  Thus, the letter designators O, I, and S (file types) are redundant to the numbers 0, 1, and 2 (file numbers).  Other file types such as B (binary), T (timers), C (counters), and others have their own default file numbers (3, 4, and 5, respectively), but may also be used in some of the user-defined file numbers (10 and above).  For example, file 7 in an Allen-Bradley controller is reserved for data of the &ldquo;integer&rdquo; type (N), but integer data may also be stored in any file numbered 10 or greater at the user's discretion.  Thus, file numbers and file type letters for data types other than output (O), input (I), and status (S) always appear together.  You would not typically see an integer word addressed as <SPAN  CLASS="texttt">N:30</SPAN> (integer word 30 in the PLC's memory) for example, but rather as <SPAN  CLASS="texttt">N7:30</SPAN> (integer word 30 <SPAN  CLASS="textit">in file 7</SPAN> of the PLC's memory) to distinguish it from other integer word 30's that may exist in other files of the PLC's memory.

<P>

<P>
This file-based addressing notation bears further explanation.  When an address appears in a PLC program, special characters are used to separate (or &ldquo;delimit&rdquo;) different fields from each other.  The general scheme for Allen-Bradley SLC 500 PLCs is shown here:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_062.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 28.26ex; vertical-align: -0.10ex; " SRC="pls/img34.svg"
 ALT="$\displaystyle \includegraphics{plc_062.eps}$">
</DIV><P></P>

<P>
Not all file types need to distinguish individual words and bits.  Integer files (N), for example, consist of one 16-bit word for each element.  For instance, <SPAN  CLASS="texttt">N7:5</SPAN> would be the 16-bit integer word number five held in file seven.  A discrete input file type (I), though, needs to be addressed as individual bits because each separate I/O point refers to a single bit.  Thus, <SPAN  CLASS="texttt">I:3/7</SPAN> would be bit number seven residing in input element three.  The &ldquo;slash&rdquo; symbol is necessary when addressing discrete I/O bits because we do not wish to refer to all sixteen bits in a word when we just mean a single input or output point on the PLC.  Integer numbers, by contrast, are collections of 16 bits each in the SLC 500 memory map, and so are usually addressed as entire words rather than bit-by-bit<A ID="tex2html5"
  HREF="footnode.html#foot800"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN></SUP></A>.

<P>
Certain file types such as timers are more complex.  Each timer &ldquo;element<A ID="tex2html6"
  HREF="footnode.html#foot801"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN></SUP></A>&rdquo; consists of <SPAN  CLASS="textit">two</SPAN> different 16-bit words (one for the timer's accumulated value, the other for the timer's target value) in addition to no less than <SPAN  CLASS="textit">three</SPAN> bits declaring the status of the timer (an &ldquo;Enabled&rdquo; bit, a &ldquo;Timing&rdquo; bit, and a &ldquo;Done&rdquo; bit).  Thus, we must make use of both the decimal-point and slash separator symbols when referring to data within a timer.  Suppose we declared a timer in our PLC program with the address <SPAN  CLASS="texttt">T4:2</SPAN>, which would be timer number two contained in timer file four.  If we wished to address that timer's current value, we would do so as <SPAN  CLASS="texttt">T4:2.ACC</SPAN> (the &ldquo;Accumulator&rdquo; word of timer number two in file four).  The &ldquo;Done&rdquo; bit of that same timer would be addressed as <SPAN  CLASS="texttt">T4:2/DN</SPAN> (the &ldquo;Done&rdquo; bit of timer number two in file four)<A ID="tex2html7"
  HREF="footnode.html#foot802"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">7</SPAN></SUP></A>.

<P>

<P>
A hallmark of the SLC 500's addressing scheme common to many legacy PLC systems is that the address labels for input and output bits explicitly reference the physical locations of the I/O channels.  For instance, if an 8-channel discrete input card were plugged into slot 4 of an Allen-Bradley SLC 500 PLC, and you wished to specify the second bit (bit 1 out of a 0 to 7 range), you would address it with the following label: <SPAN  CLASS="texttt">I:4/1</SPAN>.  Addressing the seventh bit (bit number 6) on a discrete output card plugged into slot 3 would require the label <SPAN  CLASS="texttt">O:3/6</SPAN>.  In either case, the numerical structure of that label tells you exactly where the real-world input signal connects to the PLC.  

<P>
To illustrate the relationship between physical I/O and bits in the PLC's memory, consider this example of an Allen-Bradley SLC 500 PLC, showing one of its discrete input channels energized (the switch being used as a &ldquo;Start&rdquo; switch for an electric motor):

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_016.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 70.06ex; vertical-align: -0.10ex; " SRC="pls/img35.svg"
 ALT="$\displaystyle \includegraphics{plc_016.eps}$">
</DIV><P></P>

<P>

<P>
If an input or output card possesses more than 16 bits &ndash; as in the case of the 32-bit discrete output card shown in slot 3 of the example SLC 500 rack &ndash; the addressing scheme further subdivides each element into <SPAN  CLASS="textit">words</SPAN> and bits (each &ldquo;word&rdquo; being 16 bits in length).  Thus, the address for bit number 27 of a 32-bit input module plugged into slot 3 would be <SPAN  CLASS="texttt">I:3.1/11</SPAN> (since bit 27 is equivalent to bit 11 of word 1 &ndash; word 0 addressing bits 0 through 15 and word 1 addressing bits 16 through 31): 

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_059.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 74.13ex; vertical-align: -0.10ex; " SRC="pls/img36.svg"
 ALT="$\displaystyle \includegraphics{plc_059.eps}$">
</DIV><P></P>

<P>

<P>
A close-up photograph of a 32-bit DC input card for an Allen-Bradley SLC 500 PLC system shows this multi-word addressing:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=4in]{plc_063.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 49.71ex; vertical-align: -0.10ex; " SRC="pls/img37.svg"
 ALT="$\displaystyle \includegraphics[width=4in]{plc_063.eps}$">
</DIV><P></P>

<P>
The first sixteen input points on this card (the left-hand LED group numbered 0 through 15) are addressed <SPAN  CLASS="texttt">I:X.0/0</SPAN> through <SPAN  CLASS="texttt">I:X.0/15</SPAN>, with &ldquo;<SPAN  CLASS="texttt">X</SPAN>&rdquo; referring to the slot number the card is plugged into.  The next sixteen input points (the right-hand LED group numbered 16 through 31) are addressed <SPAN  CLASS="texttt">I:X.1/0</SPAN> through <SPAN  CLASS="texttt">I:X.1/15</SPAN>. 

<P>
Legacy PLC systems typically reference each one of the I/O channels by labels such as &ldquo;I:1/3&rdquo; (or equivalent<A ID="tex2html8"
  HREF="footnode.html#foot803"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">8</SPAN></SUP></A>) indicating the actual location of the input channel terminal on the PLC unit.  The IEC 61131-3 programming standard refers to this channel-based addressing of I/O data points as <SPAN  CLASS="textit">direct addressing</SPAN>.  A synonym for direct addressing is <SPAN  CLASS="textit">absolute addressing</SPAN>.  <A NAME="276"></A>  <A NAME="277"></A>

<P>
Addressing I/O bits directly by their card, slot, and/or terminal labels may seem simple and elegant, but it becomes very cumbersome for large PLC systems and complex programs.  Every time a technician or programmer views the program, they must &ldquo;translate&rdquo; each of these I/O labels to some real-world device (e.g. &ldquo;Input <SPAN  CLASS="texttt">I:1/3</SPAN> is actually the <SPAN  CLASS="textit">Start</SPAN> pushbutton for the middle tank mixer motor&rdquo;) in order to understand the function of that bit.  A later effort to enhance the clarity of PLC programming was the concept of addressing variables in a PLC's memory by arbitrary names rather than fixed codes.  The IEC 61131-3 programming standard refers to this as <SPAN  CLASS="textit">symbolic addressing</SPAN> in contrast to &ldquo;direct&rdquo; (channel-based) addressing, allowing programmers arbitrarily name I/O channels in ways that are meaningful to the system as a whole.  To use our simple motor &ldquo;Start&rdquo; switch example, it is now possible for the programmer to designate input <SPAN  CLASS="texttt">I:1/3</SPAN> (an example of a <SPAN  CLASS="textit">direct address</SPAN>) as &ldquo;<SPAN  CLASS="texttt">Motor_start_switch</SPAN>&rdquo; (an example of a <SPAN  CLASS="textit">symbolic address</SPAN>) within the program, thus greatly enhancing the readability of the PLC program.  Initial implementations of this concept maintained direct addresses for I/O data points, with symbolic names appearing as supplements to the absolute addresses.  <A NAME="285"></A>

<P>
The modern trend in PLC addressing is to avoid the use of direct addresses such as <SPAN  CLASS="texttt">I:1/3</SPAN> altogether, so they do not appear anywhere in the programming code.  The Allen-Bradley &ldquo;Logix&rdquo; series of programmable logic controllers is the most prominent example of this new convention at the time of this writing.  Each I/O point, regardless of type or physical location, is assigned a <SPAN  CLASS="textit">tag name</SPAN> which is meaningful in a real-world sense, and these tag names (or <SPAN  CLASS="textit">symbols</SPAN> as they are alternatively called) are referenced to absolute I/O channel locations by a database file.  An important requirement of tag names is that they contain no space characters between words (e.g. instead of &ldquo;<SPAN  CLASS="texttt">Motor start switch</SPAN>&rdquo;, a tag name should use hyphens or underscore marks as spacing characters: &ldquo;<SPAN  CLASS="texttt">Motor_start_switch</SPAN>&rdquo;), since spaces are generally assumed by computer programming languages to be delimiters (separators between different variables).    <A NAME="291"></A>  <A NAME="292"></A>

<P>
<P>
Having introduced Allen-Bradley's addressing notation for SLC 500 model PLCs, I will now abandon it in favor of the modern convention of symbolic addressing throughout the rest of this chapter, so as to avoid making the programming examples brand- or model-specific.  Each data point within my PLC programs will bear its own tag name rather than a direct (channel-based) address label.

<P>

<H1><A ID="SECTION00140000000000000000">
Ladder Diagram (LD) programming</A>
</H1>

<P>
In the United States, the most common language used to program PLCs is <SPAN  CLASS="textit">Ladder Diagram</SPAN> (LD), also known as <SPAN  CLASS="textit">Relay Ladder Logic</SPAN> (RLL).  This is a graphical language showing the logical relationships between inputs and outputs as though they were contacts and coils in a hard-wired electromechanical relay circuit.  This language was invented for the express purpose of making PLC programming feel &ldquo;natural&rdquo; to electricians familiar with relay-based logic and control circuits.  While Ladder Diagram programming has many shortcomings, it remains extremely popular and so will be the primary focus of this chapter.  <A NAME="296"></A>  <A NAME="297"></A>  <A NAME="298"></A>  <A NAME="299"></A>

<P>

<P>
Every Ladder Diagram program is arranged to resemble an electrical diagram, making this a graphical (rather than text-based) programming language.  Ladder diagrams are to be thought of as <SPAN  CLASS="textit">virtual circuits</SPAN>, where virtual &ldquo;power&rdquo; flows through virtual &ldquo;contacts&rdquo; (when closed) to energize virtual &ldquo;relay coils&rdquo; to perform logical functions.  None of the contacts or coils seen in a Ladder Diagram PLC program are real; rather, they act on bits in the PLC's memory, the logical inter-relationships between those bits expressed in the form of a diagram <SPAN  CLASS="textit">resembling</SPAN> a circuit.

<P>
The following computer screenshot shows a typical Ladder Diagram program<A ID="tex2html9"
  HREF="footnode.html#foot302"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">9</SPAN></SUP></A> being edited on a personal computer:  <A NAME="303"></A>

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=6in]{plc_022.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 62.93ex; vertical-align: -0.10ex; " SRC="pls/img38.svg"
 ALT="$\displaystyle \includegraphics[width=6in]{plc_022.eps}$">
</DIV><P></P>

<P>
Contacts appear just as they would in an electrical relay logic diagram &ndash; as short vertical line segments separated by a horizontal space.  Normally-open contacts are empty within the space between the line segments, while normally-closed contacts have a diagonal line crossing through that space.  Coils are somewhat different, appearing as either circles or pairs of parentheses.  Other instructions appear as rectangular boxes.

<P>
Each horizontal line is referred to as a <SPAN  CLASS="textit">rung</SPAN>, just as each horizontal step on a stepladder is called a &ldquo;rung.&rdquo;  A common feature among Ladder Diagram program editors, as seen on this screenshot, is the ability to color-highlight those virtual &ldquo;components&rdquo; in the virtual &ldquo;circuit&rdquo; ready to &ldquo;conduct&rdquo; virtual &ldquo;power.&rdquo;  In this particular editor, the color used to indicate &ldquo;conduction&rdquo; is light blue.  Another form of status indication seen in this PLC program is the values of certain variables in the PLC's memory, shown in red text.   <A NAME="306"></A>

<P>
For example, you can see coil <SPAN  CLASS="texttt">T2</SPAN> energized at the upper-right corner of the screen (filled with light blue coloring), while coil <SPAN  CLASS="texttt">T3</SPAN> is not.  Correspondingly, each normally-open <SPAN  CLASS="texttt">T2</SPAN> contact appears colored, indicating its &ldquo;closed&rdquo; status, while each normally-closed <SPAN  CLASS="texttt">T2</SPAN> contact is uncolored.  By contrast, each normally-open <SPAN  CLASS="texttt">T3</SPAN> contact is uncolored (since coil <SPAN  CLASS="texttt">T3</SPAN> is unpowered) while each normally-closed <SPAN  CLASS="texttt">T3</SPAN> contact is shown colored to indicate its conductive status.  Likewise, the current count values of timers <SPAN  CLASS="texttt">T2</SPAN> and <SPAN  CLASS="texttt">T3</SPAN> are shown as 193 and 0, respectively.  The output value of the math instruction box happens to be 2400, also shown in red text.  <A NAME="316"></A>

<P>
Color-highlighting of Ladder Diagram components only works, of course, when the computer running the program editing software is connected to the PLC and the PLC is in the &ldquo;run&rdquo; mode (and the &ldquo;show status&rdquo; feature of the editing software is enabled).  Otherwise, the Ladder Diagram is nothing more than black symbols on a white background.  Not only is status highlighting very useful in de-bugging PLC programs, but it also serves an invaluable diagnostic purpose when a technician analyzes a PLC program to check the status of real-world input and output devices connected to the PLC.  This is especially true when the program's status is viewed remotely over a computer network, allowing maintenance staff to investigate system problems without even being near the PLC!

<P>

<H2><A ID="SECTION00141000000000000000">
Contacts and coils</A>
</H2>

<P>
The most elementary objects in Ladder Diagram programming are <SPAN  CLASS="textit">contacts</SPAN> and <SPAN  CLASS="textit">coils</SPAN>, intended to mimic the contacts and coils of electromechanical relays.  Contacts and coils are <SPAN  CLASS="textit">discrete</SPAN> programming elements, dealing with Boolean (1 and 0; on and off; true and false) variable states.  Each contact in a Ladder Diagram PLC program represents the <SPAN  CLASS="textit">reading</SPAN> of a single bit in memory, while each coil represents the <SPAN  CLASS="textit">writing</SPAN> of a single bit in memory.  <A NAME="323"></A>  <A NAME="324"></A>

<P>
Discrete input signals to the PLC from real-world switches are read by a Ladder Diagram program by contacts referenced to those input channels.  In legacy PLC systems, each discrete input channel has a specific address which must be applied to the contact(s) within that program.  In modern PLC systems, each discrete input channel has a tag name created by the programmer which is applied to the contact(s) within the program.  Similarly, discrete output channels &ndash; referenced by coil symbols in the Ladder Diagram &ndash; must also bear some form of address or tag name label.

<P>
To illustrate, we will imagine the construction and programming of a redundant flame-sensing system to monitor the status of a burner flame using three sensors.  The purpose of this system will be to indicate a &ldquo;lit&rdquo; burner if at least two out of the three sensors indicate flame.  If only one sensor indicates flame (or if no sensors indicate flame), the system will declare the burner to be un-lit.  The burner's status will be visibly indicated by a lamp that human operators can readily see inside the control room area.

<P>

<P>
Our system's wiring is shown in the following diagram:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_023.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 64.45ex; vertical-align: -0.10ex; " SRC="pls/img39.svg"
 ALT="$\displaystyle \includegraphics{plc_023.eps}$">
</DIV><P></P>

<P>
Each flame sensor outputs a DC voltage signal indicating the detection of flame at the burner, either on (24 volts DC) or off (0 volts DC).  These three discrete DC voltage signals are sensed by the first three channels of the PLC's discrete input card.  The indicator lamp is a 120 volt light bulb, and so must be powered by an AC discrete output card, shown here in the PLC's last slot.

<P>

<P>
To make the ladder program more readable, we will assign tag names (symbolic addresses) to each input and output bit in the PLC, describing its real-world device in an easily-interpreted format<A ID="tex2html10"
  HREF="footnode.html#foot804"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">10</SPAN></SUP></A>.  We will tag the first three discrete input channels as <SPAN  CLASS="texttt">IN_sensor_A</SPAN>, <SPAN  CLASS="texttt">IN_sensor_B</SPAN>, and <SPAN  CLASS="texttt">IN_sensor_C</SPAN>, and the output as <SPAN  CLASS="texttt">OUT_burner_lit</SPAN>.

<P>

<P>
A ladder program to determine if at least two out of the three sensors detect flame is shown here, with the tag names referencing each contact and coil:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_024.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 27.87ex; vertical-align: -0.10ex; " SRC="pls/img40.svg"
 ALT="$\displaystyle \includegraphics{plc_024.eps}$">
</DIV><P></P>

<P>
Series-connected contacts in a Ladder Diagram perform the logical <SPAN  CLASS="texttt">AND</SPAN> function, while parallel contacts perform the logical <SPAN  CLASS="texttt">OR</SPAN> function.  Thus, this two-out-of-three flame-sensing program could be verbally described as:

<P>
<P><!-- MATH
 \begin{displaymath}
\hbox{``Burner is lit if either \texttt{A} \textit{and} \texttt{B}, \textit{or} either \texttt{B} \textit{and} \texttt{C}, \textit{or} either \texttt{A} \textit{and} \texttt{C}''}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="pls/img41.svg"
 ALT="$\displaystyle \hbox{\lq\lq Burner is lit if either \texttt{A} \textit{and} \texttt{B...
...extit{and} \texttt{C}, \textit{or} either \texttt{A} \textit{and} \texttt{C}''}$">
</DIV><P></P>

<P>
An alternate way to express this is to use the notation of <SPAN  CLASS="textit">Boolean algebra</SPAN>, where multiplication represents the <SPAN  CLASS="texttt">AND</SPAN> function and addition represents the <SPAN  CLASS="texttt">OR</SPAN> function:

<P>
<P><!-- MATH
 \begin{displaymath}
\hbox{Burner\_lit} = AB + BC + AC
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 1.98ex; vertical-align: -0.27ex; " SRC="pls/img42.svg"
 ALT="$\displaystyle \hbox{Burner\_lit} = AB + BC + AC$">
</DIV><P></P>

<P>
Yet another way to represent this logical relationship is to use logic gate symbols:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_078.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 20.90ex; vertical-align: -0.10ex; " SRC="pls/img43.svg"
 ALT="$\displaystyle \includegraphics{plc_078.eps}$">
</DIV><P></P>

<P>

<P>
To illustrate how this program would work, we will consider a case where flame sensors B and C detect flame, but sensor A does not<A ID="tex2html11"
  HREF="footnode.html#foot357"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">11</SPAN></SUP></A>.  This represents a two-out-of-three-good condition, and so we would expect the PLC to turn on the &ldquo;Burner lit&rdquo; indicator light as programmed.  From the perspective of the PLC's rack, we would see the indicator LEDs for sensors B and C lit up on the discrete input card, as well as the indicator LED for the lamp's output channel:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_025.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 64.45ex; vertical-align: -0.10ex; " SRC="pls/img44.svg"
 ALT="$\displaystyle \includegraphics{plc_025.eps}$">
</DIV><P></P>

<P>
Those two energized input channels &ldquo;set&rdquo; bits (1 status) in the PLC's memory representing the status of flame sensors B and C.  Flame sensor A's bit will be &ldquo;clear&rdquo; (0 status) because its corresponding input channel is de-energized.  The fact that the output channel LED is energized (and the &ldquo;Burner lit&rdquo; indicator lamp is energized) tells us the PLC program has &ldquo;set&rdquo; that corresponding bit in the PLC's output memory register to a &ldquo;1&rdquo; state.

<P>

<P>
A display of input and output register bits shows the &ldquo;set&rdquo; and &ldquo;reset&rdquo; states for the PLC at this moment in time:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_061.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 12.39ex; vertical-align: -0.10ex; " SRC="pls/img45.svg"
 ALT="$\displaystyle \includegraphics{plc_061.eps}$">
</DIV><P></P>

<P>
Examining the Ladder Diagram program with status indication enabled, we see how only the middle contact pair is passing &ldquo;virtual power&rdquo; to the output coil:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_026.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 44.90ex; vertical-align: -0.10ex; " SRC="pls/img46.svg"
 ALT="$\displaystyle \includegraphics{plc_026.eps}$">
</DIV><P></P>

<P>
Recall that the purpose of a contact in a PLC program is to <SPAN  CLASS="textit">read</SPAN> the status of a bit in the PLC's memory.  These six &ldquo;virtual contacts&rdquo; read the three input bits corresponding to the three flame sensors.  Each normally-open &ldquo;contact&rdquo; will &ldquo;close&rdquo; when its corresponding bit has a value of 1, and will &ldquo;open&rdquo; (go to its normal state) when its corresponding bit has a value of 0.  Thus, we see here that the two contacts corresponding to sensor A appear without highlighting (representing no &ldquo;conductivity&rdquo; in the virtual relay circuit) because the bit for that input is reset (0).  The two contacts corresponding to sensor B and the two contacts corresponding to sensor C all appear highlighted (representing &ldquo;conductivity&rdquo; in the virtual circuit) because their bits are both set (1).  <A NAME="362"></A>

<P>
Recall also that the purpose of a coil in a PLC program is to <SPAN  CLASS="textit">write</SPAN> the status of a bit in the PLC's memory.  Here, the &ldquo;energized&rdquo; coil sets the bit for the PLC output 0 to a &ldquo;1&rdquo; state, thus activating the real-world output and sending electrical power to the &ldquo;Burner lit&rdquo; lamp.

<P>
Note that the color highlighting does <SPAN  CLASS="textit">not</SPAN> indicate a virtual contact is <SPAN  CLASS="textit">conducting</SPAN> virtual power, but merely that it is <SPAN  CLASS="textit">able</SPAN> to conduct power.  Color highlighting around a virtual coil, however, <SPAN  CLASS="textit">does</SPAN> indicate the presence of virtual &ldquo;power&rdquo; at that coil.

<P>

<P>
Contacts and relays are not just useful for implementing simple logic functions, but they may also perform <SPAN  CLASS="textit">latching</SPAN> functions as well.  A very common application of this in industrial PLC systems is a latching start/stop program for controlling electric motors by means of momentary-contact pushbutton switches.  As before, this functionality will be illustrated by means of an hypothetical example circuit and program:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_027.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 80.13ex; vertical-align: -0.10ex; " SRC="pls/img47.svg"
 ALT="$\displaystyle \includegraphics{plc_027.eps}$">
</DIV><P></P>

<P>
In this system, two pushbutton switches are connected to discrete inputs on a PLC, and the PLC in turn energizes the coil of a motor contactor relay by means of one of its discrete outputs<A ID="tex2html12"
  HREF="footnode.html#foot370"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">12</SPAN></SUP></A>.  An overload contact is wired directly in series with the contactor coil to provide motor overcurrent protection, even in the event of a PLC failure where the discrete output channel remains energized<A ID="tex2html13"
  HREF="footnode.html#foot806"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">13</SPAN></SUP></A>.  <A NAME="372"></A>

<P>
The ladder program for this motor control system would look like this:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_028.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 19.16ex; vertical-align: -0.10ex; " SRC="pls/img48.svg"
 ALT="$\displaystyle \includegraphics{plc_028.eps}$">
</DIV><P></P>

<P>
Pressing the &ldquo;Start&rdquo; pushbutton energizes discrete input channel 6 on the PLC, which &ldquo;closes&rdquo; the virtual contact in the PLC program labeled <SPAN  CLASS="texttt">IN_switch_Start</SPAN>.  The normally-closed virtual contact for input channel 7 (the &ldquo;Stop&rdquo; pushbutton) is already closed by default when the &ldquo;Stop&rdquo; button is not being pressed, and so the virtual coil will receive &ldquo;power&rdquo; when the &ldquo;Start&rdquo; pushbutton is pressed and the &ldquo;Stop&rdquo; pushbutton is not.

<P>
Note the <SPAN  CLASS="textit">seal-in</SPAN> contact bearing the exact same label as the coil: <SPAN  CLASS="texttt">OUT_contactor</SPAN>.  At first it may seem strange to have both a contact and a coil in a PLC program labeled identically<A ID="tex2html14"
  HREF="footnode.html#foot807"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">14</SPAN></SUP></A>, since contacts are most commonly associated with inputs and coils with outputs, but this makes perfect sense if you realize the true meaning of contacts and coils in a PLC program: as <SPAN  CLASS="textit">read</SPAN> and <SPAN  CLASS="textit">write</SPAN> operations on bits in the PLC's memory.  The coil labeled <SPAN  CLASS="texttt">OUT_contactor</SPAN> <SPAN  CLASS="textit">writes</SPAN> the status of that bit, while the contact labeled <SPAN  CLASS="texttt">OUT_contactor</SPAN> <SPAN  CLASS="textit">reads</SPAN> the status of that same bit.  The purpose of this contact, of course, is to latch the motor in the &ldquo;on&rdquo; state after a human operator has released his or her finger from the &ldquo;Start&rdquo; pushbutton.

<P>
This programming technique is known as <SPAN  CLASS="textit">feedback</SPAN>, where an output variable of a function (in this case, the feedback variable is <SPAN  CLASS="texttt">OUT_contactor</SPAN>) is also an input to that same function.  The path of feedback is <SPAN  CLASS="textit">implicit</SPAN> rather than <SPAN  CLASS="textit">explicit</SPAN> in Ladder Diagram programming, with the only indication of feedback being the common name shared by coil and contact.  Other graphical programming languages (such as Function Block) have the ability to show feedback paths as connecting lines between function outputs and inputs, but this capacity does not exist in Ladder Diagram.

<P>

<P>
A step-by-step sequence showing the operation and status of this simple program illustrates how the seal-in contact functions, through a start-up and shut-down cycle of the motor:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_029.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 93.29ex; vertical-align: -0.10ex; " SRC="pls/img49.svg"
 ALT="$\displaystyle \includegraphics{plc_029.eps}$">
</DIV><P></P>

<P>
This sequence helps illustrate the <SPAN  CLASS="textit">order of evaluation</SPAN> or <SPAN  CLASS="textit">scan order</SPAN> of a Ladder Diagram program.  The PLC reads a Ladder Diagram from left to right, top to bottom, in the same general order as a human being reads sentences and paragraphs written in English.  However, according to the IEC 61131-3 standard, a PLC program must evaluate (read) all inputs (contacts) to a function before determining the status of a function's output (coil or coils).  In other words, the PLC does not make any decision on how to set the state of a coil until all contacts providing power to that coil have been read.  Once a coil's status has been written to memory, any contacts bearing the same tag name will update with that status on subsequent rungs in the program.

<P>
Step 5 in the previous sequence is particularly illustrative.  When the human operator presses the &ldquo;Stop&rdquo; pushbutton, the input channel for <SPAN  CLASS="texttt">IN_switch_Stop</SPAN> becomes activated, which &ldquo;opens&rdquo; the normally-closed virtual contact <SPAN  CLASS="texttt">IN_switch_Stop</SPAN>.  Upon the next scan of this program rung, the PLC evaluates all input contacts (<SPAN  CLASS="texttt">IN_switch_Start</SPAN>, <SPAN  CLASS="texttt">IN_switch_Stop</SPAN>, and <SPAN  CLASS="texttt">OUT_contactor</SPAN>) to check their status before deciding what status to write to the <SPAN  CLASS="texttt">OUT_contactor</SPAN> coil.  Seeing that the <SPAN  CLASS="texttt">IN_switch_Stop</SPAN> contact has been forced open by the activation of its respective discrete input channel, the PLC writes a &ldquo;0&rdquo; (or &ldquo;False&rdquo;) state to the <SPAN  CLASS="texttt">OUT_contactor</SPAN> coil.  However, the <SPAN  CLASS="texttt">OUT_contactor</SPAN> feedback contact does not update until the next scan, which is why you still see it color-highlighted during step 5.

<P>
<P>
A potential problem with this system as it is designed is that the human operator loses control of the motor in the event of an &ldquo;open&rdquo; wiring failure in either pushbutton switch circuit.  For instance, if a wire fell off a screw contact for the &ldquo;Start&rdquo; pushbutton switch circuit, the motor could not be started if it was already stopped.  Similarly, if a wire fell off a screw contact for the &ldquo;Stop&rdquo; pushbutton switch circuit, the motor could not be stopped if it was already running.  In either case, a broken wire connection acts the same as the pushbutton switch's &ldquo;normal&rdquo; status, which is to keep the motor in its present state.  In some applications, this failure mode would not be a severe problem.  In many applications, though, it is quite dangerous to have a running motor that cannot be stopped.  For this reason, it is customary to design motor start/stop systems a bit differently from what has been shown here.

<P>

<P>
In order to build a &ldquo;fail-stop&rdquo; motor control system with our PLC, we must first re-wire the pushbutton switch to use its normally-closed (NC) contact:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_030.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 80.13ex; vertical-align: -0.10ex; " SRC="pls/img50.svg"
 ALT="$\displaystyle \includegraphics{plc_030.eps}$">
</DIV><P></P>

<P>
This keeps discrete input channel 7 activated when the pushbutton is unpressed.  When the operator presses the &ldquo;Stop&rdquo; pushbutton, the switch's contact will be forced open, and input channel 7 will de-energize.  If a wire happens to fall off a screw terminal in the &ldquo;Stop&rdquo; switch circuit, input channel 7 will de-energize just the same as if someone pressed the &ldquo;Stop&rdquo; pushbutton, which will automatically shut off the motor.

<P>

<P>
In order for the PLC program to work properly with this new switch wiring, the virtual contact for <SPAN  CLASS="texttt">IN_switch_Stop</SPAN> must be changed from a normally-closed (NC) to a normally-open (NO):

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_031.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 23.81ex; vertical-align: -0.10ex; " SRC="pls/img51.svg"
 ALT="$\displaystyle \includegraphics{plc_031.eps}$">
</DIV><P></P>

<P>
As before, the <SPAN  CLASS="texttt">IN_switch_Stop</SPAN> virtual contact is in the &ldquo;closed&rdquo; state when no one presses the &ldquo;Stop&rdquo; switch, enabling the motor to start any time the &ldquo;Start&rdquo; switch is pressed.  Similarly, the <SPAN  CLASS="texttt">IN_switch_Stop</SPAN> virtual contact will open any time someone presses the &ldquo;Stop&rdquo; switch, thus stopping virtual &ldquo;power&rdquo; from flowing to the <SPAN  CLASS="texttt">OUT_contactor</SPAN> coil.

<P>
Although this is a very common way to build PLC-controlled motor start/stop systems &ndash; with an NC pushbutton switch and an NO &ldquo;Stop&rdquo; virtual contact &ndash; students new to PLC programming often find this logical reversal confusing<A ID="tex2html15"
  HREF="footnode.html#foot817"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">15</SPAN></SUP></A>.  Perhaps the most common reason for this confusion is a mis-understanding of the &ldquo;normal&rdquo; concept for switch contacts, be they real or virtual.  The <SPAN  CLASS="texttt">IN_switch_Stop</SPAN> virtual contact is programmed to be normally-open (NO), but yet it is <SPAN  CLASS="textit">typically</SPAN> found in the closed state.  Recall that the &ldquo;normal&rdquo; status of any switch is its status while in a resting condition of no stimulation, <SPAN  CLASS="textit">not</SPAN> necessarily its status while the process is in a &ldquo;normal&rdquo; operating mode.  The &ldquo;normally-open&rdquo; virtual contact <SPAN  CLASS="texttt">IN_switch_Stop</SPAN> is typically found in the closed state because its corresponding input channel is typically found energized, owing to the normally-closed pushbutton switch contact, which passes real electrical power to the input channel while no one presses the switch.  Just because a switch is configured as normally-open does not necessarily mean it will be <SPAN  CLASS="textit">typically</SPAN> found in the open state!  The status of any switch contact, whether real or virtual, is a function of its configuration (NO versus NC) and the stimulus applied to it.  <A NAME="417"></A>  <A NAME="418"></A>  <A NAME="419"></A>  <A NAME="420"></A>  <A NAME="421"></A>

<P>
<P>
Another concern surrounding real-world wiring problems is what this system will do if the motor contactor coil circuit opens for any reason.  An open circuit may develop as a result of a wire falling off a screw terminal, or it may occur because the thermal overload contact tripped open due to an over-temperature event.  The problem with our motor start/stop system as designed is that it is not &ldquo;aware&rdquo; of the contactor's real status.  In other words, the PLC &ldquo;thinks&rdquo; the contactor will be energized any time discrete output channel 2 is energized, but that may not actually be the case if there is an open fault in the contactor's coil circuit.

<P>
This may lead to a dangerous condition if the open fault in the contactor's coil circuit is later cleared.  Imagine an operator pressing the &ldquo;Start&rdquo; switch but noticing the motor does not actually start.  Wondering why this may be, he or she goes to look at the overload relay to see if it is tripped.  If it is tripped, and the operator presses the &ldquo;Reset&rdquo; button on the overload assembly, the motor will immediately start because the PLC's discrete output has remained energized all the time following the pressing of the &ldquo;Start&rdquo; switch.  Having the motor start up as soon as the thermal overload is reset may come as a surprise to operations personnel, and this could be quite dangerous if anyone happens to be near the motor-powered machinery when it starts.

<P>
What would be safer is a motor control system that refuses to &ldquo;latch&rdquo; on unless the contactor actually energizes when the &ldquo;Start&rdquo; switch is pressed.  For this to be possible, the PLC must have some way of sensing the contactor's status.

<P>

<P>
In order to make the PLC &ldquo;aware&rdquo; of the contactor's real status, we may connect the auxiliary switch contact to one of the unused discrete input channels on the PLC, like this:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_032.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 80.13ex; vertical-align: -0.10ex; " SRC="pls/img52.svg"
 ALT="$\displaystyle \includegraphics{plc_032.eps}$">
</DIV><P></P>

<P>
Now, the PLC is able to sense the real-time status of the contactor via input channel 5.

<P>

<P>
We may modify the PLC program to recognize this status by assigning a new tag name to this input (<SPAN  CLASS="texttt">IN_contactor_aux</SPAN>) and using a normally-open virtual contact of this name as the seal-in contact instead of the <SPAN  CLASS="texttt">OUT_contactor</SPAN> bit:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_033.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 19.16ex; vertical-align: -0.10ex; " SRC="pls/img53.svg"
 ALT="$\displaystyle \includegraphics{plc_033.eps}$">
</DIV><P></P>

<P>
Now, if the contactor fails to energize for any reason when the operator presses the &ldquo;Start&rdquo; switch, the PLC's output will fail to latch when the &ldquo;Start&rdquo; switch is released.  When the open fault in the contactor's coil circuit is cleared, the motor will <SPAN  CLASS="textit">not</SPAN> immediately start up, but rather wait until the operator presses the &ldquo;Start&rdquo; switch again, which is a much safer operating characteristic than before.

<P>

<P>
A special class of virtual &ldquo;coil&rdquo; used in PLC ladder programming that bears mentioning is the &ldquo;latching&rdquo; coil.  These usually come in two forms: a <SPAN  CLASS="textit">set</SPAN> coil and a <SPAN  CLASS="textit">reset</SPAN> coil.  Unlike a regular &ldquo;output&rdquo; coil that positively writes to a bit in the PLC's memory with every scan of the program, &ldquo;set&rdquo; and &ldquo;reset&rdquo; coils only write to a bit in memory when energized by virtual power.  Otherwise, the bit is allowed to retain its last value.  <A NAME="429"></A>  <A NAME="430"></A>  <A NAME="431"></A>

<P>
A very simple motor start/stop program could be written with just two input contacts and two of these latching coils (both bearing the same tag name, writing to the same bit in memory):

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_034.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 50.90ex; vertical-align: -0.10ex; " SRC="pls/img54.svg"
 ALT="$\displaystyle \includegraphics{plc_034.eps}$">
</DIV><P></P>

<P>
Note the use of a normally-open (NO) pushbutton switch contact (again!), with no auxiliary contact providing status indication of the contactor to the PLC.  This is a very minimal program, shown for the strict purpose of illustrating the use of &ldquo;set&rdquo; and &ldquo;reset&rdquo; latching coils in Ladder Diagram PLC programming.

<P>
&ldquo;Set&rdquo; and &ldquo;Reset&rdquo; coils<A ID="tex2html16"
  HREF="footnode.html#foot433"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">16</SPAN></SUP></A> are examples of what is known in the world of PLC programming as <SPAN  CLASS="textit">retentive instructions</SPAN>.  A &ldquo;retentive&rdquo; instruction <SPAN  CLASS="textit">retains</SPAN> its value after being virtually &ldquo;de-energized&rdquo; in the Ladder Diagram &ldquo;circuit.&rdquo;  A standard output coil is <SPAN  CLASS="textit">non-retentive</SPAN>, which means it does not &ldquo;latch&rdquo; when de-energized.  The concept of retentive and non-retentive instructions will appear again as we explore PLC programming, especially in the area of <SPAN  CLASS="textit">timers</SPAN>.  <A NAME="438"></A>  <A NAME="439"></A>

<P>
Ordinarily, we try to avoid multiple coils bearing the same label in a PLC Ladder Diagram program.  With each coil representing a &ldquo;write&rdquo; instruction, multiple coils bearing the same name represents multiple &ldquo;write&rdquo; operations to the same bit in the PLC's memory.  Here, with latching coils, there is no conflict because each of the coils only writes to the <SPAN  CLASS="texttt">OUT_contactor</SPAN> bit when its respective contact is energized.  So long as only one of the pushbutton switches is actuated at a time, there is no conflict between the identically-named coils.

<P>
This raises the question: what would happen if <SPAN  CLASS="textit">both</SPAN> pushbutton switches were simultaneously pressed?  What would happen if <SPAN  CLASS="textit">both</SPAN> &ldquo;Set&rdquo; and &ldquo;Reset&rdquo; coils were &ldquo;energized&rdquo; at the same time?  The result is that the <SPAN  CLASS="texttt">OUT_contactor</SPAN> bit would first be &ldquo;set&rdquo; (written to a value of 1) then &ldquo;reset&rdquo; (written to a value of 0) in that order as the two rungs of the program were scanned from top to bottom.  PLCs typically do not typically update their discrete I/O registers while scanning the Ladder Diagram program (this operation takes place either before or after each program scan), so the real discrete output channel status will be whatever the <SPAN  CLASS="textit">last</SPAN> write operation told it to be, in this case &ldquo;reset&rdquo; (0, or off).

<P>
Even if the discrete output is not &ldquo;confused&rdquo; due to the conflicting write operations of the &ldquo;Set&rdquo; and &ldquo;Reset&rdquo; coils, other rungs of the program written between the &ldquo;Set&rdquo; and &ldquo;Reset&rdquo; rungs might be.  Consider for example a case where there were other program rungs following the &ldquo;Set&rdquo; and &ldquo;Reset&rdquo; rungs reading the status of the <SPAN  CLASS="texttt">OUT_contactor</SPAN> bit for some purpose.  Those other rungs <SPAN  CLASS="textit">would</SPAN> indeed become &ldquo;confused&rdquo; because they would see the <SPAN  CLASS="texttt">OUT_contactor</SPAN> bit in the &ldquo;set&rdquo; state while the actual discrete output of the PLC (and any rungs following the &ldquo;Reset&rdquo; rung) would see the <SPAN  CLASS="texttt">OUT_contactor</SPAN> bit in the &ldquo;reset&rdquo; state:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_035.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 40.64ex; vertical-align: -0.10ex; " SRC="pls/img55.svg"
 ALT="$\displaystyle \includegraphics{plc_035.eps}$">
</DIV><P></P>

<P>
Multiple (non-retentive) output coils with the same memory address are almost always a programming <SPAN  CLASS="textit">faux pax</SPAN> for this reason, but even retentive coils which are designed to be used in matched pairs can cause trouble if the implications of simultaneous energization are not anticipated.  Multiple <SPAN  CLASS="textit">contacts</SPAN> with identical addresses are no problem whatsoever, because multiple &ldquo;read&rdquo; operations to the same bit in memory will never cause a conflict.

<P>
<P>
The IEC 61131-3 PLC programming standard specifies <SPAN  CLASS="textit">transition-sensing</SPAN> contacts as well as the more customary &ldquo;static&rdquo; contacts.  A transition-sensing contact will &ldquo;actuate&rdquo; only for a duration of one program scan, even if its corresponding bit remains active.  Two types of transition-sensing Ladder Diagram contacts are defined in the IEC standard: one for <SPAN  CLASS="textit">positive</SPAN> transitions and another for <SPAN  CLASS="textit">negative</SPAN> transitions.  The following example shows a wiring diagram, Ladder Diagram program, and a timing diagram demonstrating how each type of transition-sensing contact functions when stimulated by a real (electrical) input signal to a discrete channel:  <A NAME="455"></A>  <A NAME="456"></A>

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_036.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 80.52ex; vertical-align: -0.10ex; " SRC="pls/img56.svg"
 ALT="$\displaystyle \includegraphics{plc_036.eps}$">
</DIV><P></P>

<P>
When the pushbutton switch is pressed and the discrete input energized, the first test lamp will blink &ldquo;on&rdquo; for exactly one scan of the PLC's program, then return to its off state.  The positive-transition contact (with the letter &ldquo;P&rdquo; inside) activates the coil <SPAN  CLASS="texttt">OUT_test1</SPAN> only during the scan it sees the status of <SPAN  CLASS="texttt">IN_test</SPAN> transition from &ldquo;false&rdquo; to &ldquo;true,&rdquo; even though the input remains energized for many scans after that transition.  Conversely, when the pushbutton switch is released and the discrete input de-energizes, the second test lamp will blink &ldquo;on&rdquo; for exactly one scan of the PLC's program then return to its off state.  The negative-transition contact (with the letter &ldquo;N&rdquo; inside) activates the coil <SPAN  CLASS="texttt">OUT_test2</SPAN> only during the scan it sees the status of <SPAN  CLASS="texttt">IN_test</SPAN> transition from &ldquo;true&rdquo; to &ldquo;false,&rdquo; even though the input remains de-energized for many scans after that transition:

<P>
It should be noted that the duration of a single PLC program scan is typically very short: measured in milliseconds.  If this program were actually tested in a real PLC, you would probably not be able to see either test lamp light up, since each pulse is so short-lived.  Transitional contacts are typically used any time it is desired to execute an instruction just one time following a &ldquo;triggering&rdquo; event, as opposed to executing that instruction over and over again so long as the event status is maintained &ldquo;true.&rdquo;  

<P>
<P>
Contacts and coils represent only the most basic of instructions in the Ladder Diagram PLC programming language.  Many other instructions exist, which will be discussed in the following subsections.

<P>

<H2><A ID="SECTION00142000000000000000">
Counters</A>
</H2>

<P>
A <SPAN  CLASS="textit">counter</SPAN> is a PLC instruction that either increments (counts up) or decrements (counts down) an integer number value when prompted by the transition of a bit from 0 to 1 (&ldquo;false&rdquo; to &ldquo;true&rdquo;).  Counter instructions come in three basic types: <SPAN  CLASS="textit">up</SPAN> counters, <SPAN  CLASS="textit">down</SPAN> counters, and <SPAN  CLASS="textit">up/down</SPAN> counters.  Both &ldquo;up&rdquo; and &ldquo;down&rdquo; counter instructions have single inputs for triggering counts, whereas &ldquo;up/down&rdquo; counters have two trigger inputs: one to make the counter increment and one to make the counter decrement.  <A NAME="467"></A>  <A NAME="468"></A>  <A NAME="469"></A>

<P>
To illustrate the use of a counter instruction, we will analyze a PLC-based system designed to count objects as they pass down a conveyor belt:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_037.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 65.42ex; vertical-align: -0.10ex; " SRC="pls/img57.svg"
 ALT="$\displaystyle \includegraphics{plc_037.eps}$">
</DIV><P></P>

<P>
In this system, a continuous (unbroken) light beam causes the light sensor to close its output contact, energizing discrete channel IN4.  When an object on the conveyor belt interrupts the light beam from source to sensor, the sensor's contact opens, interrupting power to input IN4.  A pushbutton switch connected to activate discrete input IN5 when pressed will serve as a manual &ldquo;reset&rdquo; of the count value.  An indicator lamp connected to one of the discrete output channels will serve as an indicator of when the object count value has exceeded some pre-set limit.  

<P>

<P>
We will now analyze a simple Ladder Diagram program designed to increment a counter instruction each time the light beam breaks:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_038.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 26.13ex; vertical-align: -0.10ex; " SRC="pls/img58.svg"
 ALT="$\displaystyle \includegraphics{plc_038.eps}$">
</DIV><P></P>

<P>
This particular counter instruction (CTU) is an incrementing counter, which means it counts &ldquo;up&rdquo; with each off-to-on transition input to its &ldquo;CU&rdquo; input.  The normally-closed virtual contact (<SPAN  CLASS="texttt">IN_sensor_object</SPAN>) is typically held in the &ldquo;open&rdquo; state when the light beam is continuous, by virtue of the fact the sensor holds that discrete input channel energized while the beam is continuous.  When the beam is broken by a passing object on the conveyor belt, the input channel de-energizes, causing the virtual contact <SPAN  CLASS="texttt">IN_sensor_object</SPAN> to &ldquo;close&rdquo; and send virtual power to the &ldquo;CU&rdquo; input of the counter instruction.  This increments the counter just as the leading edge of the object breaks the beam.  The second input of the counter instruction box (&ldquo;R&rdquo;) is the <SPAN  CLASS="textit">reset</SPAN> input, receiving virtual power from the contact <SPAN  CLASS="texttt">IN_switch_reset</SPAN> whenever the reset pushbutton is pressed.  If this input is activated, the counter immediately resets its current value (CV) to zero.

<P>
Status indication is shown in this Ladder Diagram program, with the counter's preset value (PV) of 25 and the counter's current value (CV) of 0 shown highlighted in blue.  The preset value is something programmed into the counter instruction before the system put into service, and it serves as a threshold for activating the counter's output (Q), which in this case turns on the count indicator lamp (the <SPAN  CLASS="texttt">OUT_counts_reached</SPAN> coil).  According to the IEC 61131-3 programming standard, this counter output should activate whenever the current value is equal to or greater than the preset value (Q is active if CV <SPAN CLASS="MATH"><IMG STYLE="height: 1.98ex; vertical-align: -0.41ex; " SRC="pls/img59.svg"
 ALT="$\geq$"></SPAN> PV).

<P>

<P>
This is the status of the same program after thirty objects have passed by the sensor on the conveyor belt.  As you can see, the current value of the counter has increased to 30, exceeding the preset value and activating the discrete output:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_039.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 26.13ex; vertical-align: -0.10ex; " SRC="pls/img60.svg"
 ALT="$\displaystyle \includegraphics{plc_039.eps}$">
</DIV><P></P>

<P>
If all we did not care about maintaining an accurate total count of objects past 25 &ndash; but merely wished the program to indicate when 25 objects had passed by &ndash; we could also use a <SPAN  CLASS="textit">down</SPAN> counter instruction preset to a value of 25, which turns on an output coil when the count reaches zero:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_042.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 26.13ex; vertical-align: -0.10ex; " SRC="pls/img61.svg"
 ALT="$\displaystyle \includegraphics{plc_042.eps}$">
</DIV><P></P>

<P>
Here, a &ldquo;load&rdquo; input causes the counter's current value to equal the preset value (25) when activated.  With each sensor pulse received, the counter instruction decrements.  When it reaches zero, the Q output activates.

<P>
<P>
A potential problem in either version of this object-counting system is that the PLC cannot discriminate between forward and reverse motion on the conveyor belt.  If, for instance, the conveyor belt were ever reversed in direction, the sensor would continue to count objects that had already passed by before (in the forward direction) as those objects retreated on the belt.  This would be a problem because the system would &ldquo;think&rdquo; more objects had passed along the belt (indicating greater production) than actually did.

<P>

<P>
One solution to this problem is to use an up/down counter, capable of both incrementing (counting up) and decrementing (counting down), and equip this counter with two light-beam sensors capable of determining direction of travel.  If two light beams are oriented parallel to each other, closer than the width of the narrowest object passing along the conveyor belt, we will have enough information to determine direction of object travel:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_040.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 57.48ex; vertical-align: -0.10ex; " SRC="pls/img62.svg"
 ALT="$\displaystyle \includegraphics{plc_040.eps}$">
</DIV><P></P>

<P>
This is called <SPAN  CLASS="textit">quadrature</SPAN> signal timing, because the two pulse waveforms are approximately 90<SPAN CLASS="MATH"><IMG STYLE="height: 1.70ex; vertical-align: -0.10ex; " SRC="pls/img63.svg"
 ALT="$^{o}$"></SPAN> (one-<SPAN  CLASS="textit">quarter</SPAN> of a period) apart in phase.  We can use these two phase-shifted signals to increment or decrement an up/down counter instruction, depending on which pulse leads and which pulse lags.  <A NAME="484"></A>

<P>

<P>
A Ladder Diagram PLC program designed to interpret the quadrature pulse signals is shown here, making use of negative-transition contacts as well as standard contacts:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_041.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 43.55ex; vertical-align: -0.10ex; " SRC="pls/img64.svg"
 ALT="$\displaystyle \includegraphics{plc_041.eps}$">
</DIV><P></P>

<P>
The counter will increment (count up) when sensor B de-energizes only if sensor A is already in the de-energized state (i.e. light beam A breaks before B).  The counter will decrement (count down) when sensor A de-energizes only if sensor B is already in the de-energized state (i.e. light beam B breaks before A).

<P>
<P>
Note that the up/down counter has both a &ldquo;reset&rdquo; (R) input and a &ldquo;load&rdquo; input (&ldquo;LD&rdquo;) to force the current value.  Activating the reset input forces the counter's current value (CV) to zero, just as we saw with the &ldquo;up&rdquo; counter instruction.  Activating the load input forces the counter's current value to the preset value (PV), just as we saw with the &ldquo;down&rdquo; counter instruction.  In the case of an up/down counter, there are two Q outputs: a QU (output up) to indicate when the current value is equal to or greater than the preset value, and a QD (output down) to indicate when the current value is equal to or less than zero.

<P>

<P>
Note how the current value (CV) of each counter shown is associated with a tag name of its own, in this case <SPAN  CLASS="texttt">parts_counted</SPAN>.  The integer number of a counter's current value (CV) is a variable in the PLC's memory just like boolean values such as <SPAN  CLASS="texttt">IN_sensor_A</SPAN> and <SPAN  CLASS="texttt">IN_switch_reset</SPAN>, and may be associated with a tag name or symbolic address just the same<A ID="tex2html17"
  HREF="footnode.html#foot809"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">17</SPAN></SUP></A>.  This allows other instructions in a PLC program to read (and sometimes write!) values from and to that memory location.

<P>

<H2><A ID="SECTION00143000000000000000">
Timers</A>
</H2>

<P>
A <SPAN  CLASS="textit">timer</SPAN> is a PLC instruction measuring the amount of time elapsed following an event.  Timer instructions come in two basic types: <SPAN  CLASS="textit">on-delay</SPAN> timers and <SPAN  CLASS="textit">off-delay</SPAN> timers.  Both &ldquo;on-delay&rdquo; and &ldquo;off-delay&rdquo; timer instructions have single inputs triggering the timed function.  <A NAME="495"></A>  <A NAME="496"></A>  <A NAME="497"></A>

<P>
An &ldquo;on-delay&rdquo; timer activates an output only when the input has been active for a minimum amount of time.  Take for instance this PLC program, designed to sound an audio alarm siren prior to starting a conveyor belt.  To start the conveyor belt motor, the operator must press and hold the &ldquo;Start&rdquo; pushbutton for 10 seconds, during which time the siren sounds, warning people to clear away from the conveyor belt that is about to start.  Only after this 10-second start delay does the motor actually start (and latch &ldquo;on&rdquo;):

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_043.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 77.03ex; vertical-align: -0.10ex; " SRC="pls/img65.svg"
 ALT="$\displaystyle \includegraphics{plc_043.eps}$">
</DIV><P></P>

<P>
Similar to an &ldquo;up&rdquo; counter, the on-delay timer's elapsed time (ET) value increments once per second until the preset time (PT) is reached, at which time its output (Q) activates.  In this program, the preset time value is 10 seconds, which means the Q output will not activate until the &ldquo;Start&rdquo; switch has been depressed for 10 seconds.  The alarm siren output, which is not activated by the timer, energizes immediately when the &ldquo;Start&rdquo; pushbutton is pressed.

<P>
An important detail regarding this particular timer's operation is that it be <SPAN  CLASS="textit">non-retentive</SPAN>.  This means the timer instruction should <SPAN  CLASS="textit">not</SPAN> retain its elapsed time value when the input is de-activated.  Instead, the elapsed time value should reset back to zero every time the input de-activates.  This ensures the timer resets itself when the operator releases the &ldquo;Start&rdquo; pushbutton.  A <SPAN  CLASS="textit">retentive</SPAN> on-delay timer, by contrast, maintains its elapsed time value even when the input is de-activated.  This makes it useful for keeping &ldquo;running total&rdquo; times for some event.  <A NAME="502"></A>  <A NAME="503"></A>

<P>
Most PLCs provide retentive and non-retentive versions of on-delay timer instructions, such that the programmer may choose the proper form of on-delay timer for any particular application.  The IEC 61131-3 programming standard, however, addresses the issue of retentive versus non-retentive timers a bit differently.  According to the IEC 61131-3 standard, a timer instruction may be specified with an additional <SPAN  CLASS="textit">enable</SPAN> input (EN) that causes the timer instruction to behave non-retentively when activated, and retentively when de-activated.  The general concept of the enable (EN) input is that the instruction behaves &ldquo;normally&rdquo; so long as the enable input is active (in this case, non-retentive timing action is considered &ldquo;normal&rdquo; according to the IEC 61131-3 standard), but the instruction &ldquo;freezes&rdquo; all execution whenever the enable input de-activates.  This &ldquo;freezing&rdquo; of operation has the effect of retaining the current time (CT) value even if the input signal de-activates.

<P>

<P>
For example, if we wished to add a retentive timer to our conveyor control system to record total run time for the conveyor motor, we could do so using an &ldquo;enabled&rdquo; IEC 61131-3 timer instruction like this:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_045.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 29.61ex; vertical-align: -0.10ex; " SRC="pls/img66.svg"
 ALT="$\displaystyle \includegraphics{plc_045.eps}$">
</DIV><P></P>

<P>
When the motor's contactor bit (<SPAN  CLASS="texttt">OUT_contactor</SPAN>) is active, the timer is enabled and allowed to time.  However, when that bit de-activates (becomes &ldquo;false&rdquo;), the timer instruction as a whole is disabled, causing it to &ldquo;freeze&rdquo; and retain its current time (CT) value<A ID="tex2html18"
  HREF="footnode.html#foot507"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">18</SPAN></SUP></A>.  This allows the motor to be started and stopped, with the timer maintaining a tally of total motor run time.

<P>

<P>
If we wished to give the operator the ability to manually reset the total run time value to zero, we could hard-wire an additional switch to the PLC's discrete input card and add &ldquo;reset&rdquo; contacts to the program like this:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_044.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 29.61ex; vertical-align: -0.10ex; " SRC="pls/img67.svg"
 ALT="$\displaystyle \includegraphics{plc_044.eps}$">
</DIV><P></P>

<P>
Whenever the &ldquo;Reset&rdquo; switch is pressed, the timer is enabled (EN) but the timing input (IN) is disabled, forcing the timer to (non-retentively) reset its current time (CT) value to zero.

<P>

<P>
The other major type of PLC timer instruction is the <SPAN  CLASS="textit">off-delay</SPAN> timer.  This timer instruction differs from the on-delay type in that the timing function begins as soon as the instruction is de-activated, not when it is activated.  An application for an off-delay timer is a cooling fan motor control for a large industrial engine.  In this system, the PLC starts an electric cooling fan as soon as the engine is detected as rotating, and keeps that fan running for two minutes following the engine's shut-down to dissipate residual heat:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_046.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 52.64ex; vertical-align: -0.10ex; " SRC="pls/img68.svg"
 ALT="$\displaystyle \includegraphics{plc_046.eps}$">
</DIV><P></P>

<P>
When the input (IN) to this timer instruction is activated, the output (Q) immediately activates (with no time delay at all) to turn on the cooling fan motor contactor.  This provides the engine with cooling as soon as it begins to rotate (as detected by the speed switch connected to the PLC's discrete input).  When the engine stops rotating, the speed switch returns to its normally-open position, de-activating the timer's input signal which starts the timing sequence.  The Q output remains active while the timer counts from 0 seconds to 120 seconds.  As soon as it reaches 120 seconds, the output de-activates (shutting off the cooling fan motor) and the elapsed time value remains at 120 seconds until the input re-activates, at which time it resets back to zero.  <A NAME="511"></A>

<P>

<P>
The following timing diagrams compare and contrast on-delay with off-delay timers:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_047.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 42.39ex; vertical-align: -0.10ex; " SRC="pls/img69.svg"
 ALT="$\displaystyle \includegraphics{plc_047.eps}$">
</DIV><P></P>

<P>
While it is common to find on-delay PLC instructions offered in both retentive and non-retentive forms within the instruction sets of nearly every PLC manufacturer and model, it is almost unheard of to find retentive off-delay timer instructions.  Typically, off-delay timers are non-retentive only<A ID="tex2html19"
  HREF="footnode.html#foot810"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">19</SPAN></SUP></A>.

<P>

<H2><A ID="SECTION00144000000000000000">
Data comparison instructions</A>
</H2>

<P>
As we have seen with counter and timers, some PLC instructions generate digital values other than simple Boolean (on/off) signals.  Counters have current value (CV) registers and timers have elapsed time (ET) registers, both of which are typically integer number values.  Many other PLC instructions are designed to receive and manipulate non-Boolean values such as these to perform useful control functions.

<P>
The IEC 61131-3 standard specifies a variety of <SPAN  CLASS="textit">data comparison</SPAN> instructions for comparing two non-Boolean values, and generating Boolean outputs.  The basic comparative operations of &ldquo;less than&rdquo; (<SPAN CLASS="MATH"><IMG STYLE="height: 1.47ex; vertical-align: -0.16ex; " SRC="pls/img70.svg"
 ALT="$&lt;$"></SPAN>), &ldquo;greater than&rdquo; (<SPAN CLASS="MATH"><IMG STYLE="height: 1.47ex; vertical-align: -0.16ex; " SRC="pls/img29.svg"
 ALT="$&gt;$"></SPAN>), &ldquo;less than or equal to&rdquo; (<SPAN CLASS="MATH"><IMG STYLE="height: 1.98ex; vertical-align: -0.41ex; " SRC="pls/img71.svg"
 ALT="$\leq$"></SPAN>), &ldquo;greater than or equal to&rdquo; (<SPAN CLASS="MATH"><IMG STYLE="height: 1.98ex; vertical-align: -0.41ex; " SRC="pls/img59.svg"
 ALT="$\geq$"></SPAN>), &ldquo;equal to&rdquo; (=), and &ldquo;not equal to&rdquo; (<SPAN CLASS="MATH"><IMG STYLE="height: 2.25ex; vertical-align: -0.55ex; " SRC="pls/img72.svg"
 ALT="$\neq$"></SPAN>) may be found as a series of &ldquo;box&rdquo; instructions in the IEC standard:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_048.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 48.77ex; vertical-align: -0.10ex; " SRC="pls/img73.svg"
 ALT="$\displaystyle \includegraphics{plc_048.eps}$">
</DIV><P></P>

<P>
The Q output for each instruction &ldquo;box&rdquo; activates whenever the evaluated comparison function is &ldquo;true&rdquo; and the enable input (EN) is active.  If the enable input remains active but the comparison function is false, the Q output de-activates.  If the enable input de-de-activates, the Q output retains its last state.

<P>

<P>
A practical application for a comparative function is something called <SPAN  CLASS="textit">alternating motor control</SPAN>, where the run-times of two redundant electric motors<A ID="tex2html20"
  HREF="footnode.html#foot518"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">20</SPAN></SUP></A> are monitored, with the PLC determining which motor to turn on next based on which motor has run the least:  <A NAME="519"></A>

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_049.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 85.55ex; vertical-align: -0.10ex; " SRC="pls/img74.svg"
 ALT="$\displaystyle \includegraphics{plc_049.eps}$">
</DIV><P></P>

<P>
In this program, two retentive on-delay timers keep track of each electric motor's total run time, storing the run time values in two registers in the PLC's memory: <SPAN  CLASS="texttt">Motor_A_runtime</SPAN> and <SPAN  CLASS="texttt">Motor_B_runtime</SPAN>.  These two integer values are input to the &ldquo;greater than&rdquo; instruction box for comparison.  If motor A has run longer than motor B, motor B will be the one enabled to start up next time the &ldquo;start&rdquo; switch is pressed.  If motor A has run less time or the same amount of time as motor B (the scenario shown by the blue-highlighted status indications), motor A will be the one enabled to start.  The two series-connected virtual contacts <SPAN  CLASS="texttt">OUT_motor_A</SPAN> and <SPAN  CLASS="texttt">OUT_motor_B</SPAN> ensure the comparison between motor run times is not made until both motors are stopped.  If the comparison were continually made, a situation might arise where <SPAN  CLASS="textit">both</SPAN> motors would start if someone happened to press the Start pushbutton with one motor is already running.

<P>

<H2><A ID="SECTION00145000000000000000">
Math instructions</A>
</H2>

<P>
The IEC 61131-3 standard specifies several dedicated ladder instructions for performing arithmetic calculations.  Some of them are shown here:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_052.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 81.10ex; vertical-align: -0.10ex; " SRC="pls/img75.svg"
 ALT="$\displaystyle \includegraphics{plc_052.eps}$">
</DIV><P></P>

<P>
As with the data comparison instructions, each of these math instructions must be enabled by an &ldquo;energized&rdquo; signal to the enable (EN) input.  Input and output values are linked to each math instruction by tag name.

<P>

<P>
An example showing the use of such instructions is shown here, converting a temperature measurement in units of degrees Fahrenheit to units of degrees Celsius.  In this particular case, the program inputs a temperature measurement of 138 <SPAN CLASS="MATH"><IMG STYLE="height: 1.70ex; vertical-align: -0.10ex; " SRC="pls/img63.svg"
 ALT="$^{o}$"></SPAN>F and calculates the equivalent temperature of 58.89 <SPAN CLASS="MATH"><IMG STYLE="height: 1.70ex; vertical-align: -0.10ex; " SRC="pls/img63.svg"
 ALT="$^{o}$"></SPAN>C:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_053.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 78.77ex; vertical-align: -0.10ex; " SRC="pls/img76.svg"
 ALT="$\displaystyle \includegraphics{plc_053.eps}$">
</DIV><P></P>

<P>
Note how two separate math instructions were required to perform this simple calculation, as well as a dedicated variable (<SPAN  CLASS="texttt">X</SPAN>) used to store the intermediate calculation between the subtraction and the division &ldquo;boxes.&rdquo;

<P>
<P>
Although not specified in the IEC 61131-3 standard, many programmable logic controllers support Ladder Diagram math instructions allowing the direct entry of arbitrary equations.  Rockwell (Allen-Bradley) Logix5000 programming, for example, has the &ldquo;Compute&rdquo; (<SPAN  CLASS="texttt">CPT</SPAN>) function, which allows any typed expression to be computed in a single instruction as opposed to using several dedicated math instructions such as &ldquo;Add,&rdquo; &ldquo;Subtract,&rdquo; etc.  General-purpose math instructions dramatically shorten the length of a ladder program compared to the use of dedicated math instructions for any applications requiring non-trivial calculations.  <A NAME="533"></A>

<P>

<P>
For example, the same Fahrenheit-to-Celsius temperature conversion program implemented in Logix5000 programming only requires a single math instruction and no declarations of intermediate variables:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_054.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 42.19ex; vertical-align: -0.10ex; " SRC="pls/img77.svg"
 ALT="$\displaystyle \includegraphics{plc_054.eps}$">
</DIV><P></P>

<P>

<H2><A ID="SECTION00146000000000000000">
Sequencers</A>
</H2>

<P>
Many industrial processes require control actions to take place in certain, predefined sequences.  Batch processes are perhaps the most striking example of this, where materials for making a batch must be loaded into the process vessels, parameters such as temperature and pressure controlled during the batch processing, and then discharge of the product monitored and controlled.  Before the advent of reliable programmable logic devices, this form of sequenced control was usually managed by an electromechanical device known as a <SPAN  CLASS="textit">drum sequencer</SPAN>.  This device worked on the principle of a rotating cylinder (drum) equipped with tabs to actuate switches as the drum rotated into certain positions.  If the drum rotated at a constant speed (turned by a clock motor), those switches would actuate according to a timed schedule<A ID="tex2html21"
  HREF="footnode.html#foot811"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">21</SPAN></SUP></A>.  <A NAME="538"></A> 

<P>
The following photograph shows a drum sequencer with 30 switches.  Numbered tabs on the circumference of the drum mark the drum's rotary position in one of 24 increments.  With this number of switches and tabs, the drum can control up to thirty discrete (on/off) devices over a series of twenty-four sequenced steps:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=16cm]{plc_050.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 46.06ex; vertical-align: -0.10ex; " SRC="pls/img78.svg"
 ALT="$\displaystyle \includegraphics[width=16cm]{plc_050.eps}$">
</DIV><P></P>

<P>

<P>
A typical application for a sequencer is to control a <SPAN  CLASS="textit">Clean In Place</SPAN> (<SPAN  CLASS="textit">CIP</SPAN>) system for a food processing vessel, where a process vessel must undergo a cleaning cycle to purge it of any biological matter between food processing cycles.  The steps required to clean the vessel are well-defined and must always occur in the same sequence in order to ensure hygienic conditions.  An example timing chart is shown here:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_051.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 75.68ex; vertical-align: -0.10ex; " SRC="pls/img79.svg"
 ALT="$\displaystyle \includegraphics{plc_051.eps}$">
</DIV><P></P>

<P>
In this example, there are nine discrete outputs &ndash; one for each of the nine final control elements (pumps and valves) &ndash; and seventeen steps to the sequence, each one of them timed.  In this particular sequence, the only input is the discrete signal to commence the CIP cycle.  From the initiation of the CIP to its conclusion two and a half hours (150 minutes) later, the sequencer simply steps through the programmed routine.

<P>
<P>
Another practical application for a sequencer is to implement a <SPAN  CLASS="textit">Burner Management System</SPAN> (BMS), also called a <SPAN  CLASS="textit">flame safety system</SPAN>.  Here, the sequencer manages the safe start-up of a combustion burner: beginning by &ldquo;purging&rdquo; the combustion chamber with fresh air to sweep out any residual fuel vapors, waiting for the command to light the fire, energizing a spark ignition system on command, and then continuously monitoring for presence of good flame and proper fuel supply pressure once the burner is lit.  <A NAME="545"></A>  <A NAME="546"></A>  <A NAME="547"></A>

<P>
<P>
In a general sense, the operation of a drum sequencer is that of a <SPAN  CLASS="textit">state machine</SPAN>: the output of the system depends on the condition of the machine's internal state (the drum position), not just the conditions of the input signals.  Digital computers are very adept at implementing state functions, and so the general function of a drum sequencer should be (and is) easy to implement in a PLC.  Other PLC functions we have seen (&ldquo;latches&rdquo; and timers in particular) are similar, in that the PLC's output at any given time is a function of both its present input condition(s) and its past input condition(s).  Sequencing functions expand upon this concept to define a much larger number of possible states (&ldquo;positions&rdquo; of a &ldquo;drum&rdquo;), some of which may even be timed.

<P>
Unfortunately, despite the utility of drum sequence functions and their ease of implementation in digital form, there seems to be very little standardization between PLC manufacturers regarding sequencing instructions.  Sadly, the IEC 61131-3 standard (at least at the time of this writing, in 2009) does not specifically define a sequencing function suitable for Ladder Diagram programming.  PLC manufacturers are left to invent sequencing instructions of their own design.  What follows here is an exploration of some different sequencer instructions offered by PLC manufacturers.

<P>

<H3><A ID="SECTION00146100000000000000">
Koyo &ldquo;drum&rdquo; instructions</A>
</H3>

<P>
The <SPAN  CLASS="textit">drum</SPAN> instruction offered in Koyo PLCs is a model of simplicity itself.  This instruction is practically self-explanatory, as shown in the following example:  <A NAME="551"></A>

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_066.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 50.90ex; vertical-align: -0.10ex; " SRC="pls/img80.svg"
 ALT="$\displaystyle \includegraphics{plc_066.eps}$">
</DIV><P></P>

<P>
The three-by-three grid of squares represent steps in the sequence and bit states for each step.  Rows represent steps, while columns represent output bits written by the drum instruction.  In this particular example, a three-step sequence proceeds at the command of a single input (<SPAN  CLASS="texttt">X001</SPAN>), and the drum instruction's advance from one step to the next proceeds strictly on the basis of elapsed time (a <SPAN  CLASS="textit">time base</SPAN> orientation).  When the input is active, the drum proceeds through its timed sequence.  When the input is inactive, the drum halts wherever it left off, and resumes timing as soon as the input becomes active again.  

<P>
Being based on time, each step in the drum instruction has a set time duration for completion.  The first step in this particular example has a duration of 10 seconds, the second step 15 seconds, and the third step 18 seconds.  At the first step, only output bit <SPAN  CLASS="texttt">Y001</SPAN> is set.  In the second step, only output bit <SPAN  CLASS="texttt">Y002</SPAN> is set.  In the third step, output bits <SPAN  CLASS="texttt">Y002</SPAN> and <SPAN  CLASS="texttt">Y003</SPAN> are set (1), while bit <SPAN  CLASS="texttt">Y001</SPAN> is reset (0).  The colored versus uncolored boxes reveal which output bits are set and reset with each step.  The current step number is held in memory register <SPAN  CLASS="texttt">DS1</SPAN>, while the elapsed time (in seconds) is stored in timer register <SPAN  CLASS="texttt">TD1</SPAN>.  A &ldquo;complete&rdquo; bit is set at the conclusion of the three-step sequence.

<P>
Koyo drum instructions may be expanded to include more than three steps and more than three output bits, with each of those step times independently adjustable and each of the output bits arbitrarily assigned to any writable bit addresses in the PLC's memory.

<P>

<P>
This next example of a Koyo drum instruction shows how it may be set up to trigger on <SPAN  CLASS="textit">events</SPAN> rather than on elapsed times.  This orientation is called an <SPAN  CLASS="textit">event base</SPAN>:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_067.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 50.90ex; vertical-align: -0.10ex; " SRC="pls/img81.svg"
 ALT="$\displaystyle \includegraphics{plc_067.eps}$">
</DIV><P></P>

<P>
Here, a three-step sequence proceeds when enabled by a single input (<SPAN  CLASS="texttt">X001</SPAN>), with the drum instruction's advance from one step to the next proceeding only as the different event condition bits become set.  When the input is active, the drum proceeds through its sequence when each event condition is met.  When the input is inactive, the drum halts wherever it left off regardless of the event bit states.

<P>
For example, during the first step (when only output bit <SPAN  CLASS="texttt">Y001</SPAN> is set), the drum instruction waits for the first condition input bit <SPAN  CLASS="texttt">X002</SPAN> to become set (1) before proceeding to step 2, with time being irrelevant.  When this happens, the drum immediately advances to step 2 and waits for input bit <SPAN  CLASS="texttt">X003</SPAN> to be set, and so forth.  If all three event conditions were met simultaneously (<SPAN  CLASS="texttt">X002</SPAN>, <SPAN  CLASS="texttt">X003</SPAN>, and <SPAN  CLASS="texttt">X004</SPAN> all set to 1), the drum would skip through all steps as fast as it could (one step per PLC program scan) with no appreciable time elapsed for each step.  Conversely, the drum instruction will wait as long as it must for the right condition to be met before advancing, whether that event takes place in milliseconds or in days.

<P>

<H3><A ID="SECTION00146200000000000000">
Allen-Bradley sequencer instructions</A>
</H3>

<P>
Rockwell (Allen-Bradley) PLCs use a more sophisticated set of instructions to implement sequences.  The closest equivalent to Koyo's <SPAN  CLASS="textit">drum</SPAN> instruction is the Allen-Bradley <SPAN  CLASS="textit">SQO</SPAN> (Sequencer Output) instruction, shown here:  <A NAME="575"></A>  <A NAME="576"></A> 

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_068.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 38.71ex; vertical-align: -0.10ex; " SRC="pls/img82.svg"
 ALT="$\displaystyle \includegraphics{plc_068.eps}$">
</DIV><P></P>

<P>
You will notice there are no colored squares inside the SQO instruction box to specify when certain bits are set or reset throughout the sequence, in contrast to the simplicity of the Koyo PLC's drum instruction.  Instead, the Allen-Bradley SQO instruction is told to read a set of 16-bit words beginning at a location in the PLC's memory arbitrarily specified by the programmer, one word at a time.  It steps to the next word in that set of words with each new position (step) value.  This means Allen-Bradley sequencer instructions rely on the programmer already having pre-loaded an area of the PLC's memory with the necessary 1's and 0's defining the sequence.  This makes the Allen-Bradley sequencer instruction more challenging for a human programmer to interpret because the bit states are not explicitly shown inside the SQO instruction box, but it also makes the sequencer far more flexible in that these bits are not fixed parameters of the SQO instruction and therefore may be dynamically altered as the PLC runs.  With the Koyo drum instruction, the assigned output states are part of the instruction itself, and are therefore fixed once the program is downloaded to the PLC (i.e. they cannot be altered without editing and re-loading the PLC's program).  With the Allen-Bradley, the on-or-off bit states for the sequence may be freely altered<A ID="tex2html22"
  HREF="footnode.html#foot578"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">22</SPAN></SUP></A> during run-time.  This is a very useful feature in recipe-control applications, where the recipe is subject to change at the whim of production personnel, and they would rather not have to rely on a technician or an engineer to re-program the PLC for each new recipe.

<P>
The &ldquo;Length&rdquo; parameter tells the SQO instruction how many words will be read (i.e. how many steps are in the entire sequence).  The sequencer advances to each new position when its enabling input transitions from inactive to active (from &ldquo;false&rdquo; to &ldquo;true&rdquo;), just like a count-up (CTU) instruction increments its accumulator value with each new false-to-true transition of the input.  Here we see another important difference between the Allen-Bradley SQO instruction and the Koyo drum instruction: the Allen-Bradley instruction is fundamentally <SPAN  CLASS="textit">event-driven</SPAN>, and does not proceed on its own like the Koyo drum instruction is able to when configured for a <SPAN  CLASS="textit">time</SPAN> base.

<P>
Sequencer instructions in Allen-Bradley PLCs use a notation called <SPAN  CLASS="textit">indexed addressing</SPAN> to specify the locations in memory for the set of 16-bit words it will read.  In the example shown above, we see the &ldquo;File&rdquo; parameter specified as <SPAN  CLASS="texttt">#B3:0</SPAN>.  The &ldquo;#&rdquo; symbol tells the instruction that this is a <SPAN  CLASS="textit">starting</SPAN> location in memory for the first 16-bit word, when the instruction's position value is zero.  As the position value increments, the SQO instruction reads 16-bit words from successive addresses in the PLC's memory.  If <SPAN  CLASS="texttt">B3:0</SPAN> is the word referenced at position 0, then <SPAN  CLASS="texttt">B3:1</SPAN> will be the memory address read at position 1, <SPAN  CLASS="texttt">B3:2</SPAN> will be the memory address read at position 2, etc.  Thus, the &ldquo;position&rdquo; value causes the SQO instruction to &ldquo;point&rdquo; or &ldquo;index&rdquo; to successive memory locations.

<P>
<P>
The bits read from each indexed word in the sequence are compared against a static mask<A ID="tex2html23"
  HREF="footnode.html#foot812"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">23</SPAN></SUP></A> specifying which bits in the indexed word are relevant.  At each position, only these bits are written to the destination address.

<P>
As with most other Allen-Bradley instructions, the sequencer requires the human programmer to declare a special area in memory reserved for the instruction's internal use.  The &ldquo;<SPAN  CLASS="texttt">R6</SPAN>&rdquo; file exists just for this purpose, each element in that file holding bit and integer values associated with a sequencer instruction (e.g. the &ldquo;enable&rdquo; and &ldquo;done&rdquo; bits, the array length, the current position, etc.).

<P>

<P>
To illustrate, let us examine a set of bits held in the <SPAN  CLASS="texttt">B3</SPAN> file of an Allen-Bradley SLC 500 PLC, showing how each row (element) of this data file would be read by an SQO instruction as it stepped through its positions:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_070.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 20.13ex; vertical-align: -0.10ex; " SRC="pls/img83.svg"
 ALT="$\displaystyle \includegraphics{plc_070.eps}$">
</DIV><P></P>

<P>
The sequencer's position number is added to the file reference address as an <SPAN  CLASS="textit">offset</SPAN>.  Thus, if the data file is specified in the SQO instruction box as <SPAN  CLASS="texttt">#B3:0</SPAN>, then <SPAN  CLASS="texttt">B3:1</SPAN> will be the row of bits read when the sequencer's position value is 1, <SPAN  CLASS="texttt">B3:2</SPAN> will be the row of bits read when the position value is 2, and so on.

<P>
The <SPAN  CLASS="textit">mask</SPAN> value specified in the SQO instruction tells the instruction which bits out of each row will be copied to the destination address.  A mask value of FFFFh (FFFF in <SPAN  CLASS="textit">hexadecimal</SPAN> format) means all 16 bits of each <SPAN  CLASS="texttt">B3</SPAN> word will be read and written to the destination.  A mask value of 0001h means only the first (least-significant) bit will be read and written, with the rest being ignored.  

<P>
Let's see what would happen with an SQO instruction having a mask value of 000Fh, starting from file index <SPAN  CLASS="texttt">#B3:0</SPAN>, and writing to a destination that is output register <SPAN  CLASS="texttt">O:0.0</SPAN>, given the bit array values in file <SPAN  CLASS="texttt">B3</SPAN> shown above:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_071.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 30.19ex; vertical-align: -0.10ex; " SRC="pls/img84.svg"
 ALT="$\displaystyle \includegraphics{plc_071.eps}$">
</DIV><P></P>

<P>
When this SQO instruction is at position 2, it reads the bit values <SPAN  CLASS="texttt">0010</SPAN> from <SPAN  CLASS="texttt">B3:2</SPAN> and writes only those four bits to <SPAN  CLASS="texttt">O:0.0</SPAN>.  The &ldquo;X&rdquo; symbols shown in the illustration mean that all the other bits in that output register are untouched &ndash; the SQO instruction does not write to those bits because they are &ldquo;masked off&rdquo; from being written.  You may think of the mask's zero bits inhibiting source bits from being written to the destination word in the same sense that <SPAN  CLASS="textit">masking tape</SPAN> prevents paint from being applied to a surface.  <A NAME="608"></A> 

<P>

<P>
The following Allen-Bradley SLC 500 PLC program shows how a pair of SQO instructions plus an on-delay timer instruction may be used to duplicate the exact same functionality as the &ldquo;time base&rdquo; Koyo drum instruction presented earlier:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_069.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 43.35ex; vertical-align: -0.10ex; " SRC="pls/img85.svg"
 ALT="$\displaystyle \includegraphics{plc_069.eps}$">
</DIV><P></P>

<P>
The first SQO instruction reads bits in the <SPAN  CLASS="texttt">B3</SPAN> file array, sending only the three least-significant of them to the output register <SPAN  CLASS="texttt">O:0.0</SPAN> (as specified by the 0007h mask value).  The second SQO instruction reads integer number values from elements of the <SPAN  CLASS="texttt">N7</SPAN> integer file and places them into the &ldquo;preset&rdquo; register of timer <SPAN  CLASS="texttt">T4:0</SPAN>, so as to dynamically update the timer's preset value with each step of the sequence.  The timer, in turn, counts off each of the time delays and then enables both sequencers to advance to the next position when the specified time has elapsed.  Here we see a tremendous benefit of the SQO instruction's indexed memory addressing: the fact that the SQO instruction reads its bits from arbitrarily-specified memory addresses means we may use SQO instructions to sequence <SPAN  CLASS="textit">any type of data existing in the PLC's memory!</SPAN>  We are not limited to turning on and off individual bits as we are with the Koyo drum instruction, but rather are free to index whole integer numbers, ASCII characters, or any other forms of binary data resident in the PLC's memory. 

<P>
Data file windows appear on the computer screen showing the bit array held in the <SPAN  CLASS="texttt">B3</SPAN> file as well as the timer values held in the <SPAN  CLASS="texttt">N7</SPAN> file.  In this live screenshot, we see both sequencer instructions at position 2, with the second SQO instruction having loaded a value of 15 seconds from register <SPAN  CLASS="texttt">N7:2</SPAN> to the timer's preset register <SPAN  CLASS="texttt">T4:0.PRE</SPAN>.

<P>
Note how the enabling contact address for the second SQO instruction is the &ldquo;enable&rdquo; bit of the first instruction, ensuring both instructions are enabled simultaneously.  This keeps the two separate sequencers synchronized (on the same step).

<P>

<P>
Event-based transitions may be implemented in Allen-Bradley PLCs using a complementary sequencing instruction called SQC (Sequencer Compare).  The SQC instruction is set up very similar to the SQO instruction, with an indexed file reference address to read from, a reserved memory structure for internal use, a set length, and a position value.  The purpose of the SQC instruction is to read a data register and compare it against another data register, setting a &ldquo;found&rdquo; (<SPAN  CLASS="texttt">FD</SPAN>) bit if the two match.  Thus, the SQC instruction is ideally suited for detecting when certain conditions have been met, and thus may be used to enable an SQO instruction to proceed to the next step in its sequence.  <A NAME="620"></A>  <A NAME="621"></A>

<P>
The following program example shows an Allen-Bradley MicroLogix 1100 PLC programmed with both an SQO and an SQC instruction:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_072.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 44.90ex; vertical-align: -0.10ex; " SRC="pls/img86.svg"
 ALT="$\displaystyle \includegraphics{plc_072.eps}$">
</DIV><P></P>

<P>
The three-position SQO (Sequencer Output) instruction reads data from <SPAN  CLASS="texttt">B3:1</SPAN>, <SPAN  CLASS="texttt">B3:2</SPAN>, and <SPAN  CLASS="texttt">B3:3</SPAN>, writing the four least-significant of those bits to output register <SPAN  CLASS="texttt">O:0.0</SPAN>.  The three-position SQC (Sequencer Compare) instruction reads data from <SPAN  CLASS="texttt">B3:6</SPAN>, <SPAN  CLASS="texttt">B3:7</SPAN>, and <SPAN  CLASS="texttt">B3:8</SPAN>, comparing the four least-significant of those bits against input bits in register <SPAN  CLASS="texttt">I:0.0</SPAN>.  When the four input bit conditions match the selected bits in the <SPAN  CLASS="texttt">B3</SPAN> file, the SQC instruction's <SPAN  CLASS="texttt">FD</SPAN> bit is set, causing both the SQO instruction and the SQC instruction to advance to the next step.

<P>
<P>

<P>
Lastly, Allen-Bradley PLCs offer a third sequencing instruction called <SPAN  CLASS="textit">Sequencer Load</SPAN> (SQL), which performs the opposite function as the Sequencer Output (SQO).  An SQL instruction takes data from a designated source and writes it into an indexed register according to a position count value, rather than reading data from an indexed register and sending it to a designated destination as does the SQO instruction.  SQL instructions are useful for reading data from a live process and storing it in different registers within the PLC's memory at different times, such as when a PLC is used for <SPAN  CLASS="textit">datalogging</SPAN> (recording process data).  <A NAME="635"></A>  <A NAME="636"></A>

<P>

<H2><A ID="SECTION00147000000000000000">
PID regulator i PLS programmer</A>
</H2>

<P>
PID regulatoren i Codesys aktiveres ved å laste inn biblioteket Util
som ligger under Application_Common_Util. 

<P>
Dette er en enkel PID regulator som fungerer etter formelen. 

<P>
<P><!-- MATH
 \begin{displaymath}
\ensuremath{Y=KP\cdot(e+\frac{1}{TN}\int edt+TV\frac{\delta e}{\delta t})+Y_{OFFSET}}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 5.36ex; vertical-align: -2.10ex; " SRC="pls/img87.svg"
 ALT="$\displaystyle \ensuremath{Y=KP\cdot(e+\frac{1}{TN}\int edt+TV\frac{\delta e}{\delta t})+Y_{OFFSET}}
$">
</DIV><P></P>

<P>
Her er et lite eksempel på en temperaturregulering med regulatoren.
Prøv på din egen PC om du får dette til å virke. 

<P>
For å gjøre regulatoren lett å ta i bruk har vi på Gand lagt inn en
strukt som enkelt senere kan refereres til. En må da ha Gand funksjonsbiblioteket. 

<P>
Variablene rundt regulatoren vil da se ut som i Figur.

<P>
Prøv å tilpass programmet du nettopp har laget til bruke denne strukten,
og de tilhørende symbolene i HMI-en. 

<P>

<H1><A ID="SECTION00150000000000000000">
Structured Text (ST) programming</A>
</H1>

<P>
(Will be addressed in future versions of this book)

<P>
<P>

<H1><A ID="SECTION00160000000000000000">
Instruction List (IL) programming</A>
</H1>

<P>
(Will be addressed in future versions of this book)

<P>
<P>

<H1><A ID="SECTION00170000000000000000">
Function Block Diagram (FBD) programming</A>
</H1>

<P>
(Will be addressed in future versions of this book)

<P>
<P>

<H1><A ID="SECTION00180000000000000000">
Sequential Function Chart (SFC) programmering</A>
</H1>
<P>
Mål for læringen er at eleven skal: 
<UL>
<LI>Vite hva en som kjennetegner en sekvensiell styring 
</LI>
<LI>Kunne tegne et sekvensielt funksjonskart 
</LI>
<LI>Kunne lage PLS program i LD (ladder) for en sekvens
</LI>
<LI>Kunne lage PLS program i SFC for en sekvens 
</LI>
<LI>Kunne sette opp paralelle sekvenser og valg mellom sekvenser
</LI>
</UL>
En sekvensiell styring betyr en rekke aktiviteter som skjer i en bestemt rekkefølge.
Som eksempel på sekvensstyring kan vi ta for oss en vaskemaskin: 

<P>
Sekvensen kan være slik: 

<P>

<UL>
<LI>Åpne påfyllingskran.
</LI>
<LI>Når en nivåsensor gir signal om at tanken er full
</LI>
<LI>Steng kranen.
</LI>
<LI>Skru på varmeelementet.
</LI>
<LI>Når en temperatursensor gir signal om at ønsket temperatur er oppnådd
</LI>
<LI>Skru av varmeelementet.
</LI>
<LI>Start trommelmotoren.
</LI>
<LI>Etter en viss tid, stopp den.
 
</LI>
</UL> 

<P>
For å beskrive en sekvens med symboler finnes det en internasjonal
standard med betegnelsen ISO 61131-3. Denne beskriver både overgangene
mellom aktivitetene og hva som skal skje i de ulike aktivitetstrinn
og kalles Sekvensielt Funksjons Kart (SFC)

<P>
SFC &rdquo;språket&rdquo; egner seg godt for overordnet styring.
<P>

<H2><A ID="SECTION00181000000000000000">
Sekvensielt funksjonskart</A>
</H2>

<P>
For å beskrive en sekvensiel styring brukes et sekvensielt funksjonskart.
Dette kan beskrive de sekvensielle sidene av et kontroll program. 

<P>
SFC viser:

<UL>
<LI>hoved tilstandene til en maskin eller en prosess
</LI>
<LI>alle mulige tilstandsforandringer
</LI>
<LI>betingelsene som disse forandringene vil skje med.
</LI>
</UL>

<P>

<H3><A ID="SECTION00181100000000000000">
SFC elementer</A>
</H3>

<P>
SFC elementer brukes til å strukturere et sekvensprogram. Dette gjøres
ved å beskrive styringssekvensen ved hjelp av:

<UL>
<LI>Hva som skal kjøre
</LI>
<LI>Når det skal kjøre
</LI>
<LI>Hvordan det skal kjøres
</LI>
</UL>
<IMG STYLE=""
 SRC="pls/SFC13.png"
 ALT="Image SFC13">

<P>
Vi kan dele en sekvensstyring i to deler:

<OL>
<LI>Sekvensdelen som bestemmer i hvilken rekkefølge sekvensen skal gå.
</LI>
<LI>Kontrolldelen som bestemmer hva som skal gjøres i hver del.
</LI>
</OL>

<P>

<H3><A ID="SECTION00181200000000000000">
SFC Steg typer. </A>
</H3>

<P>
Det finnes to typer steg i SFC

<UL>
<LI>Init
</LI>
<LI>Normalt
</LI>
</UL>

<P>
Init steget er det steget som programmet vil stå i når det starter opp, eller der det vil gå til om en resetter sekvensen. 

<P>
Init steget har følgende egenskaper:

<UL>
<LI>Hver SFC POU må ha et init steg
</LI>
<LI>det kan bare være et init steg pr. POU
</LI>
<LI>Init steget definerer steget som POU-en starter opp i ved cold-start. 
</LI>
<LI>Init steget er aktivt inntil overgangsbetingelsen blir sann. 
</LI>
</UL>

<P>
Et steg har to tilhørende variabler som vi kan bruke til å monitorere og synkronisere sekvensen. 

<UL>
<LI>STEP.x er en variabel som er TRUE når steget er aktivt. 
</LI>
<LI>STEP.t er en variabel av type TIME, en kan se på denne som en stoppeklokke som starter nå trinnet aktiveres og tar tiden på hvor lenge treinnet har vært aktivt. 
</LI>
</UL>

<P>
For at disse variablene skal være tilgjengeligge må vi bruke IEC steg. Det hender at dette ikke stemmer, vi kan da tvinge et steg til å være IEC ved å legge steget inn som følgende variabel i POU-en . 
<PRE>
VAR

        Stegnavn: SFCSTEPTYPE;

END_VAR
</PRE>

<P>
<SPAN  CLASS="textbf">Eksempel</SPAN>:
Dette programmet vil stå i <code>INIT</code> til <code>INIT.t</code> er blitt større en 5s, da vil overgangsbetingelsen være <code>TRUE</code> og programmet gå videre til <code>STEP</code>.
<IMG STYLE=""
 SRC="pls/SFC14.png"
 ALT="Image SFC14">

<P>

<H3><A ID="SECTION00181300000000000000">
SFC transition</A>
</H3>

<P>
Det som avgjør når en  går fra et steg til et annet er overgangbetingelser (transitions). For å gå til neste steg må overgangsbetingelsen være <code>TRUE</code>.  

<P>
Betingelser for transition:

<UL>
<LI>det må være en transition mellom hvert steg
</LI>
<LI>Når transition er TRUE deaktiveres det aktive trinnet og neste trinn aktiveres. 
</LI>
<LI>En transition gjøres i den vertikale linken mellom to steg. 
</LI>
<LI>En transition må resultere i en enkel BOOL verdi. 
</LI>
<LI>Om en transition er tenkt å alltid være sann kan den skrives som TRUE. 
</LI>
</UL>
I Codesys har vi to typer tranitions:

<UL>
<LI>direkte (da skrives en logisk ligning i selve transitionen. 
</LI>
<LI>en detaljert som kjører en ekstern funksjon kalt transition.
</LI>
</UL>
<SPAN  CLASS="textbf">Eksempel</SPAN>

<P>
I dette programmer står nå i steget <code>Yellow1</code> og venter på overgangsbetingelsen <code>YellowDone</code>. Men dette er ikke en vanlig overgangsbetingelse. Det kan en se på firkantet over overgangs betingelse. Denne har et grønt hjørne. Dette hjørnet markerer at det er et eksternt program som kjøres. Når variablen <code>YellowDone</code> blir <code>TRUE</code> i dette programmet er også overgangsbetingelsen aktiv og vi går videre til neste steg <code>Red1</code>.
<IMG STYLE=""
 SRC="pls/SFCTransitioneksempel.png"
 ALT="Image SFCTransitioneksempel">

<P>
En ser at transitions programmet <code>YellowDone</code> består av en linje:
<code>YellowDone := Yellow1.t &gt; t#3s</code>
Det vil si at overgangsbetingelsen vil være <code>TRUE</code> når timeren <code>Yellow1.t</code> er større en 3s. 

<H3><A ID="SECTION00181400000000000000">
SFC Actions</A>
</H3>
Actions brukes til å bestemme hva som skal skje i hvert trinn. En action kan være en variabel som settes <code>TRUE</code> eller det kan være et eget program som kjøres. 
<IMG STYLE=""
 SRC="pls/SFC15.png"
 ALT="Image SFC15">

<P>
Egenskaper ved actions

<UL>
<LI>Hver action tilhører et step. 
</LI>
<LI>det kan være flere actions pr. steg
</LI>
<LI>hvis det ikke er noe action ved et steg behandles det som et vente
steg, som bare venter på neste transition
</LI>
<LI>Action qualifyers forandre hvordan et actions oppfører seg. 
</LI>
<LI>en acton kan skrives i alle IEC 61131-3 programmerinspråk. 
</LI>
<LI>en action kjøres minst to ganger, den kan altså ikke brukes til å telle opp hver gang et steg er aktivt. 
</LI>
</UL>

<P>
<DIV class="CENTER">
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="CENTER" COLSPAN=3><SPAN>Action Qualifiers according to IEC 61131-3</SPAN></TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=85>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=283>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">Qualifier</TD>
<TD CLASS="LEFT">Betydning</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=43>Forklaring</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=85>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=283>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">N</TD>
<TD CLASS="LEFT">Non-stored</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=43>Actionen er aktiv så lenge steget er aktivt.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=85>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=283>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">R0</TD>
<TD CLASS="LEFT">overriding Reset</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=43>Actinen blir deaktivert</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=85>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=283>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">S0</TD>
<TD CLASS="LEFT">Set (Stored)</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=43>Actionen blir aktiv og forblir aktiv til den resettes med R0. Den vilforble aktiv selv om sekvensen går over til et nytt trinn</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=85>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=283>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">L</TD>
<TD CLASS="LEFT">time Limited</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=43>Actionen blir aktiv med en gang og er aktiv til sekvensen går til neste trinn, eller til gitt tid er gått</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=85>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=283>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">D</TD>
<TD CLASS="LEFT">time Delayed</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=43>Actionen blir aktiv</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=85>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=283>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">P</TD>
<TD CLASS="LEFT">Pulse</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=43>Utfører actionen to ganger en gang når steget aktiveres og en gang når det deaktiveres.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=85>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=283>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">SD</TD>
<TD CLASS="LEFT">Stored and time Delayed</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=43>Actionen aktiveres etter gitt tid er gått, og vil være aktiv til den resettes.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=85>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=283>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">DS</TD>
<TD CLASS="LEFT">Delayed and Stored</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=43>Actionen aktiveres etter gitt tid er gått, men bare om trinnet fortsatt er aktivt. Den vil være aktiv til den resettes.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=85>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=283>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">SL</TD>
<TD CLASS="LEFT">Stored and time Limited</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=43>Actionen aktiveres så snart trinnet er aktivt, og vil være aktivt til gitt tid er gått eller den resettes.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=85>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT MIDDLE"  WIDTH=283>&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
</TABLE>
</DIV>

<SPAN  CLASS="textbf">Eksempel</SPAN>
Her er det eksempel på SFC sine store styrker. En prosess har blitt stående fast i steget Speed2. 
<BR>
<P>
Hva er galt? 
<P>
<IMG STYLE=""
 SRC="pls/SFC_stoppet_maskin.png"
 ALT="Image SFC_stoppet_maskin">
<br>
Hastighen holdes ikke konstant. 
SFC gir over oversikt over hvor programmet er og hva det venter på. Dette letter feilsøking på maskiner som bruker SFC.

<H4><A ID="SECTION00181410000000000000">
Oppgave til elever</A>
</H4>
<BR>
<P>

<UL>
<LI>Hva gjør programmet?
</LI>
<LI>Hvilket steg står det i for øyeblikket?
</LI>
<LI>Hva skjer i hvert steg?
</LI>
<LI>Hva får det til å gå fra ett steg til et annet?
</LI>
<LI>Er flere steg aktive sammtidig?
</LI>
</UL>

<P>
<IMG STYLE=""
 SRC="pls/SFC_EnkeltTrefikkLys.png"
 ALT="Image SFC_EnkeltTrefikkLys">
<br>
<SPAN  CLASS="textbf">Eksempel</SPAN>
<br>
Kombinering av språk ved hjelp av actionblokker
<br>

<P>
<IMG STYLE=""
 SRC="pls/SFC_KombinasjonavSpråk.png"
 ALT="Image SFC_KombinasjonavSpråk">
<br>
Dette er et eksempel på hvordan actions kan være programmer og at en står fritt til å velge hvilket program en ønsker å programere det i. 

<H3><A ID="SECTION00181500000000000000">
Alternative og parallelle sekvenser. </A>
</H3>

<P>
I SFC kan vi ha en linær sekvens der alle stegene kommer etterhverandre
og til slutt og oppe til starten igjen. 

<P>
Vi kan også ha alternative og parallelle sekvenser. I alternative
vil et seg etterfølges av to eller flere transitions, det bare en
vei kan velges. Mens i parallelle vil en transittion etterfølges av
to eller flere steg. 

<P>
Eksempel på sekvensstyring:

<P>
<DIV class="CENTER">
</DIV>
<P>
<DIV class="CENTER">
</DIV>

<P>
Funksjonstabell for lysanlegget

<P>
<DIV class="CENTER">
</DIV>
<P>
<DIV class="CENTER">
</DIV>

<P>

<H1><A ID="SECTION00190000000000000000">
Human-Machine Interfaces</A>
</H1>

<P>
Programmable logic controllers are built to input various signal types (discrete, analog), execute control algorithms on those signals, and then output signals in response to control processes.  By itself, a PLC generally lacks the capability of displaying those signal values and algorithm variables to human operators.  A technician or engineer with access to a personal computer and the requisite software for editing the PLC's program may connect to the PLC and view the program's status &ldquo;online&rdquo; to monitor signal values and variable states, but this is not a practical way for operations personnel to monitor what the PLC is doing on a regular basis.  In order for operators to monitor and adjust parameters inside the PLC's memory, we need a different sort of interface allowing certain variables to be read and written without compromising the integrity of the PLC by exposing too much information or allowing any unqualified person to alter the program itself.

<P>
One solution to this problem is a dedicated computer display programmed to provide selective access to certain variable's in the PLC's memory, generally referred to as <SPAN  CLASS="textit">Human<A ID="tex2html24"
  HREF="footnode.html#foot706"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">24</SPAN></SUP></A>-Machine Interface</SPAN>, or <SPAN  CLASS="textit">HMI</SPAN>.  <A NAME="708"></A>  <A NAME="709"></A>

<P>
HMIs may take the form of general-purpose (&ldquo;personal&rdquo;) computers running special graphic software to interface with a PLC, or as special-purpose computers designed to be mounted in sheet metal panel fronts to perform no task but the operator-PLC interface.  This first photograph shows an example of an ordinary personal computer (PC) with HMI software running on it:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=3in]{hmi_01.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 32.51ex; vertical-align: -0.10ex; " SRC="pls/img88.svg"
 ALT="$\displaystyle \includegraphics[width=3in]{hmi_01.eps}$">
</DIV><P></P>

<P>
The display shown here happens to be for monitoring a vacuum swing adsorption (VSA) process for purifying oxygen extracted from ambient air.  Somewhere, a PLC (or collection of PLCs) is monitoring and controlling this VSA process, with the HMI software acting as a &ldquo;window&rdquo; into the PLC's memory to display pertinent variables in an easy-to-interpret form for operations personnel.  The personal computer running this HMI software connects to the PLC(s) via digital network cables such as Ethernet.

<P>

<P>
This next photograph shows an example of a special-purpose HMI panel designed and built expressly to be used in industrial operating environments:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=4in]{hmi_02.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 28.32ex; vertical-align: -0.10ex; " SRC="pls/img89.svg"
 ALT="$\displaystyle \includegraphics[width=4in]{hmi_02.eps}$">
</DIV><P></P>

<P>
These HMI panels are really nothing more than &ldquo;hardened&rdquo; personal computers built ruggedly and in a compact format to facilitate their use in industrial environments.  Most industrial HMI panels come equipped with touch-sensitive screens, allowing operators to press their fingertips on displayed objects to change screens, view details on portions of the process, etc.

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{plc_076.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 38.52ex; vertical-align: -0.10ex; " SRC="pls/img90.svg"
 ALT="$\displaystyle \includegraphics{plc_076.eps}$">
</DIV><P></P>

<P>
Technicians and/or engineers program HMI displays to read and write data via a digital network to one or more PLCs.  Graphical objects arrayed on the display screen of an HMI often mimic real-world indicators and switches, in order to provide a familiar interface for operations personnel.  A &ldquo;pushbutton&rdquo; object on the face of an HMI panel, for example, would be configured to <SPAN  CLASS="textit">write</SPAN> one bit of data to the PLC, in a manner similar to a real-world switch writing one bit of data to the PLC's input register.

<P>

<P>
Modern HMI panels and software are almost exclusively tag-based, with each graphic object on the screen associated with at least one data tag name, which in turn is associated to data points (bits, or words) in the PLC by way of a tag name database file resident in the HMI.  Graphic objects on the HMI screen either accept (read) data from the PLC to present useful information to the operator, send (write) data to the PLC from operator input, or both.  The task of programming an HMI unit consists of building a tag name database and then drawing screens to illustrate the process to as good a level of detail as operators will need to run it.  <A NAME="714"></A>

<P>
An example screenshot of a tag name database table for a modern HMI is shown here:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=6in]{digital_72.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 37.85ex; vertical-align: -0.10ex; " SRC="pls/img91.svg"
 ALT="$\displaystyle \includegraphics[width=6in]{digital_72.eps}$">
</DIV><P></P>

<P>
The tag name database is accessed and edited using the same software to create graphic images in the HMI.  In this particular example you can see several tag names (e.g. <SPAN  CLASS="texttt">START_PUSHBUTTON</SPAN>, <SPAN  CLASS="texttt">MOTOR_RUN_TIMER</SPAN>, <SPAN  CLASS="texttt">ERROR_MESSAGE</SPAN>, <SPAN  CLASS="texttt">MOTOR_SPEED</SPAN>) associated with data points within the PLC's memory (in this example, the PLC addresses are shown in Modbus register format).  In many cases the tag name editor will be able to display corresponding PLC memory points in the same manner as they appear in the PLC programming editor software (e.g. <SPAN  CLASS="texttt">I:5/10</SPAN>, <SPAN  CLASS="texttt">SM0.4</SPAN>, <SPAN  CLASS="texttt">C11</SPAN>, etc.).

<P>
<P>
An important detail to note in this tag name database display is the read/write attributes of each tag.  Note in particular how four of the tags shown are <SPAN  CLASS="textit">read-only</SPAN>: this means the HMI only has permission to read the values of those four tags from the PLC's memory, and not to write (alter) those values.  The reason for this in the case of these four tags is that those tags refer to PLC input data points.  The <SPAN  CLASS="texttt">START_PUSHBUTTON</SPAN> tag, for instance, refers to a discrete input in the PLC energized by a real pushbutton switch.  As such, this data point gets its state from the energization of the discrete input terminal.  If the HMI were to be given <SPAN  CLASS="textit">write</SPAN> permission for this data point, there would likely be a conflict.  Suppose input terminal on the PLC were energized (setting the <SPAN  CLASS="texttt">START_PUSHBUTTON</SPAN> bit to a &ldquo;1&rdquo; state) and the HMI simultaneously attempted to write a &ldquo;0&rdquo; state to the same tag.  One of these two data sources would win, and other would lose, possibly resulting in unexpected behavior from the PLC program.  For this reason, data points in the PLC linked to real-world inputs should always be limited as &ldquo;read-only&rdquo; permission in the HMI's database, so the HMI cannot possibly generate a conflict.

<P>
The potential for data conflict also exists for some of the other points in the database, however.  A good example of this is the <SPAN  CLASS="texttt">MOTOR_RUN</SPAN> bit, which is the bit within the PLC program telling the real-world motor to run.  Presumably, this bit gets its data from a coil in the PLC's Ladder Diagram program.  However, since it also appears in the HMI database with <SPAN  CLASS="textit">read/write</SPAN> permission, the potential exists for the HMI to over-write (i.e. conflict) that same bit in the PLC's memory.  Suppose someone programmed a toggling &ldquo;pushbutton&rdquo; screen object in the HMI linked to this tag: pushing this virtual &ldquo;button&rdquo; on the HMI screen would attempt to set the bit (1), and pushing it again would attempt to reset the bit (0).  If this same bit is being written to by a coil in the PLC's program, however, there exists the distinct possibility that the HMI's &ldquo;pushbutton&rdquo; object and the PLC's coil will conflict, one trying to tell the bit to be a &ldquo;0&rdquo; while the other tries to tell that bit to be a &ldquo;1&rdquo;.  This situation is quite similar to the problem experienced when multiple coils in a Ladder Diagram program are addressed to the same bit.

<P>
The general rule to follow here is <SPAN  CLASS="textit">never allow more than one element to write to any data point</SPAN>.  In my experience teaching PLC and HMI programming, this is one of the more common errors students make when first learning to program HMIs: they will try to have both the HMI and the PLC writing to the same memory locations, with weird results.

<P>
<P>
One of the lessons you will learn when programming large, complex systems is that it is very beneficial to define all the necessary tag names <SPAN  CLASS="textit">before</SPAN> beginning to lay out graphics in an HMI.  The same goes for PLC programming: it makes the whole project go faster with less confusion if you take the time to define all the necessary I/O points (and tag names, if the PLC programming software supports tag names in the programming environment) before you begin to create any code specifying how those inputs and outputs will relate to each other.  

<P>
Maintaining a consistent convention for tag names is important, too.  For example, you may wish to begin the tag name of every hard-wired I/O point as either <SPAN  CLASS="texttt">INPUT</SPAN> or <SPAN  CLASS="texttt">OUTPUT</SPAN> (e.g. <SPAN  CLASS="texttt">INPUT_PRESSURE_SWITCH_HIGH</SPAN>, <SPAN  CLASS="texttt">OUTPUT_SHAKER_MOTOR_RUN</SPAN>, etc.).  The reason for maintaining a strict naming convention is not obvious at first, since the whole point of tag names is to give the programmer the freedom to assign <SPAN  CLASS="textit">arbitrary names</SPAN> to data points in the system.  However, you will find that most tag name editors list the tags in alphabetical order, which means a naming convention organized in this way will present all the input tags contiguously (adjacent) in the list, all the output tags contiguously in the list, and so on.  <A NAME="736"></A>  

<P>

<P>
Another way to leverage the alphabetical listing of tag names to your advantage is to begin each tag name with a word describing its association to a major piece of equipment.  Take for instance this example of a process with several data points defined in a PLC control system and displayed in an HMI:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics{hmi_03.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 80.32ex; vertical-align: -0.10ex; " SRC="pls/img92.svg"
 ALT="$\displaystyle \includegraphics{hmi_03.eps}$">
</DIV><P></P>

<P>

<P>
If we list all these tags in alphabetical order, the association is immediately obvious:

<P>

<UL>
<LI><SPAN  CLASS="texttt">Exchanger_effluent_pump</SPAN>
</LI>
<LI><SPAN  CLASS="texttt">Exchanger_effluent_temp_out</SPAN>
</LI>
<LI><SPAN  CLASS="texttt">Exchanger_preheat_pump</SPAN>
</LI>
<LI><SPAN  CLASS="texttt">Exchanger_preheat_temp_in</SPAN>
</LI>
<LI><SPAN  CLASS="texttt">Exchanger_preheat_valve</SPAN>
</LI>
<LI><SPAN  CLASS="texttt">Reactor_bed_temp</SPAN>
</LI>
<LI><SPAN  CLASS="texttt">Reactor_feed_flow</SPAN>
</LI>
<LI><SPAN  CLASS="texttt">Reactor_feed_temp</SPAN>
</LI>
<LI><SPAN  CLASS="texttt">Reactor_jacket_valve</SPAN>
</LI>
</UL>

<P>
As you can see from this tag name list, all the tags directly associated with the heat exchanger are located in one contiguous group, and all the tags directly associated with the reactor are located in the next contiguous group.  In this way, judicious naming of tags serves to group them in hierarchical fashion, making them easy for the programmer to locate at any future time in the tag name database.

<P>
You will note that all the tag names shown here lack space characters between words (e.g. instead of &ldquo;<SPAN  CLASS="texttt">Reactor bed temp</SPAN>&rdquo;, a tag name should use hyphens or underscore marks as spacing characters: &ldquo;<SPAN  CLASS="texttt">Reactor_bed_temp</SPAN>&rdquo;), since spaces are generally assumed by computer programming languages to be delimiters (separators between different variable names).

<P>
<P>
Like programmable logic controllers themselves, the capabilities of HMIs have been steadily increasing while their price decreases.  Modern HMIs support graphic trending, data archival, advanced alarming, and even web server ability allowing other computers to easily access certain data over wide-area networks.  The ability of HMIs to log data over long periods of time relieves the PLC of having to do this task, which is very memory-intensive.  This way, the PLC merely &ldquo;serves&rdquo; current data to the HMI, and the HMI is able to keep a record of current and past data using its vastly larger memory reserves<A ID="tex2html25"
  HREF="footnode.html#foot751"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">25</SPAN></SUP></A>.  <A NAME="752"></A>  <A NAME="753"></A>  <A NAME="754"></A>

<P>
Some modern HMI panels even have a PLC built inside the unit, providing control and monitoring in the same device.  Such panels provide terminal strip connection points for discrete and even analog I/O, allowing all control and interface functions to be located in a single panel-mount unit.

<P>

<H1><A ID="SECTION001100000000000000000">
How to teach yourself PLC programming</A>
</H1>

<P>
First and foremost, you need to get your very own PLC to work with.  Computer programming of any kind is not a spectator sport, and can only be learned by significant investment of time and effort at the keyboard.  In many ways, learning to program is like learning a new spoken or written language: there is new vocabulary and new grammatical rules to master, and many ways to make mistakes.

<P>
Fortunately, many low-cost PLCs exist on the market for individuals to purchase.  My own personal favorites are the &ldquo;CLICK&rdquo; PLC models manufactured by Koyo and marketed through Automation Direct, and also the Allen-Bradley MicroLogix series of PLC (especially the 1000 and 1100 models).  <A NAME="756"></A>  <A NAME="757"></A>

<P>
The first document you should read once you get your PLC is something called a <SPAN  CLASS="textit">Getting Started</SPAN> guide.  Every PLC manufacturer publishes a document with this name (or something similar such as <SPAN  CLASS="textit">Quick Start</SPAN> or <SPAN  CLASS="textit">Getting Results</SPAN>).  This manual will step you through all the basic procedures for entering a simple program into your PLC and getting it to run.  It is generally <SPAN  CLASS="textit">far</SPAN> easier to learn programming by copying and adapting a worked example than it is to start from a &ldquo;blank page&rdquo; on your own, just as it is easiest to learn a spoken or written language by practicing sentences spoken in that language by other people before constructing your own sentences from scratch.

<P>
In order to work with your PLC, you will need a convenient way to simulate different input conditions coming from discrete (switch) devices.  Any set of hand-operated switches will do, my recommendation being household light switches (very inexpensive and rugged).  Attaching an array of these switches to a wooden board along with the PLC and interconnecting terminal blocks forms what is often called a PLC <SPAN  CLASS="textit">trainer</SPAN>.  The following photograph shows one such trainer<A ID="tex2html26"
  HREF="footnode.html#foot763"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">26</SPAN></SUP></A>, using an Allen-Bradley MicroLogix 1000 PLC: 

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=16cm]{plc_060.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 43.06ex; vertical-align: -0.10ex; " SRC="pls/img93.svg"
 ALT="$\displaystyle \includegraphics[width=16cm]{plc_060.eps}$">
</DIV><P></P>

<P>

<P>
Another example of a student-built PLC trainer is this unit, housed inside of an attaché case.  Not only does this trainer contain an Allen-Bradley MicroLogix 1100 PLC along with input switches and output indicator lights, but it also includes an HMI touch-screen panel on a fold-down bracket:

<P>
<P><!-- MATH
 \begin{displaymath}
\includegraphics[width=16cm]{plc_077.eps}
\end{displaymath}
 -->
</P>
<DIV CLASS="displaymath">
<IMG STYLE="height: 50.81ex; vertical-align: -0.10ex; " SRC="pls/img94.svg"
 ALT="$\displaystyle \includegraphics[width=16cm]{plc_077.eps}$">
</DIV><P></P>

<P>
The educational value of building your own PLC trainer is difficult to overstate when learning about PLCs.  Learning how to build properly-functioning I/O circuits is every bit as important to a working technician as learning how to develop PLC programs.  Additionally, the experience gained in general wiring layout and fabrication are valuable skills for any instrumentation practitioner.

<P>
<P>

<P>
Once you have learned the basic steps for entering, running, and saving a PLC program, you are ready to begin building your knowledge of the language's vocabulary and grammar.  In computer programming (of all types), there are different <SPAN  CLASS="textit">functions</SPAN> of the language one must become familiar with in order to do useful tasks.  A great way to learn how to use these functions is to create your own &ldquo;demonstration&rdquo; programs illustrating the use of each function.

<P>
For example, if you open up the pages of almost any computer programming book, somewhere near the beginning you will find a demonstration program called &ldquo;Hello World!&rdquo;  The purpose of a &ldquo;Hello World!&rdquo; program is to do nothing more than display the words <SPAN  CLASS="textit">Hello World!</SPAN> on the computer screen.  It is an entirely useless program to run, but it is highly useful for gaining teaching the programmer the basics of program construction and text message functionality.  <A NAME="768"></A>

<P>
By the same token, you may learn the basics of each programming function by writing simple &ldquo;Hello World&rdquo;-type programs illustrating each one of those functions.  These demonstration programs will not serve any useful purpose (other than to help you learn), and should be kept as simple as possible in order to minimize confusion.

<P>
For example, <SPAN  CLASS="textit">every</SPAN> PLC provides instructions to perform the following tasks:

<P>

<UL>
<LI>Turn discrete outputs on and off
</LI>
<LI>Count discrete events
</LI>
<LI>Time events
</LI>
<LI>Control events in a specific sequence
</LI>
<LI>Compare numerical values (greater than, less than, equal, not equal)
</LI>
<LI>Perform arithmetic functions
</LI>
</UL>

<P>
Just as every spoken or written language has verbs, nouns, adjectives, and adverbs to describe actions and things, every PLC programming language has specific functions to perform useful tasks.  The details of how to perform each function will vary somewhat between PLC manufacturers and models, but the overall functions are quite similar.  The reference manuals provided for your PLC will describe in detail how to use each function.  Your task is to write simple demonstration programs for each function, allowing you to directly explore how each function works, and to gain an understanding of each function by observing its behavior and also by making (inevitable) mistakes.

<P>
After writing each demonstration program, you should add a lot of comments to it, so you will be able to understand what you did later when you go back to your demonstration program for reference.  These comments should cover the following points:

<P>

<UL>
<LI>Proper use of the function
</LI>
<LI>A verbal description of what the function does
</LI>
<LI>A list of possible (practical) uses for the function
</LI>
<LI>Idiosyncrasies of the function (i.e. odd or unexpected behavior, tricky points to watch out for)
</LI>
<LI>Mistakes you may have made (and thus might make again!) in using the function
</LI>
</UL>

<P>
<P>

<P>
Years ago when I was teaching myself how to program using the <SPAN  CLASS="textit">C</SPAN> language, I wrote a set of &ldquo;tutorial&rdquo; programs demonstrating common programming functions and techniques.  The following is a partial list of these tutorial programs, which I still keep to this day:

<P>

<UL>
<LI>Program that accepts and then prints alphanumeric characters (including their equivalent numerical values)
</LI>
<LI>Program demonstrating how to use command-line arguments to the <SPAN  CLASS="texttt">main()</SPAN> function
</LI>
<LI>Program demonstrating basic &ldquo;curses&rdquo; commands for plotting characters at arbitrary locations on the screen
</LI>
<LI>Program illustrating the declaration and use of <SPAN  CLASS="textit">data structures</SPAN>
</LI>
<LI>Program illustrating how to prototype and then call <SPAN  CLASS="textit">functions</SPAN> (subroutines)
</LI>
<LI>Program executing an infinite loop 
</LI>
<LI>Program illustrating how to return a <SPAN  CLASS="textit">pointer</SPAN> from a function 
</LI>
</UL>

<P>
Each one of these tutorial programs is heavily commented, to explain to myself in my own words how they work and what they are doing.  Not only did they help me learn how to write programs in C, but they also serve as a handy reference for me any time in the future I need to refresh my knowledge.  The act of writing tutorial programs is akin to <SPAN  CLASS="textit">journaling</SPAN> as a way to work through complex problems in life &ndash; in a way, it is like having a conversation with yourself.

<P>

<H1><A ID="SECTION001110000000000000000">
Review of fundamental principles</A>
</H1>

<P>
Shown here is a partial listing of principles applied in the subject matter of this chapter, given for the purpose of expanding the reader's view of this chapter's concepts and of their general inter-relationships with concepts elsewhere in the book.  Your abilities as a problem-solver and as a life-long learner will be greatly enhanced by mastering the applications of these principles to a wide variety of topics, the more varied the better.

<P>

<UL>
<LI><SPAN  CLASS="textbf">&ldquo;Normal&rdquo; switch status</SPAN>: the &ldquo;normal&rdquo; status of a switch contact as defined by the manufacturer is its <SPAN  CLASS="textit">resting</SPAN> condition (minimum stimulus).
</LI>
<LI><SPAN  CLASS="textbf">&ldquo;Seal-in&rdquo; circuit</SPAN>: when an electrical relay uses one of its own switch contacts to continue its own coil energization after the initial triggering event has passed.  Relevant to all manner of relay control circuits.
</LI>
<LI><SPAN  CLASS="textbf">Sourcing versus sinking</SPAN>: whether the electronic device in question is outputting (conventional flow) current or inputting current.  Relevant to the proper connection of discrete DC input and output cards.
</LI>
</UL>

<P>

<H1><A ID="SECTION001120000000000000000">
References</A>
</H1>

<P>

&ldquo;1758 PLC-5 Programmable Controllers Addressing Reference Manual&rdquo;, Publication 5000-6.4.4, Allen-Bradley Company, Inc., Milwaukee, WI, 1995.

<P>
<P>

&ldquo;Allen-Bradley I/O Modules Wiring Diagrams&rdquo;, Publication CIG-WD001A-EN-P, Rockwell Automation, Inc., Milwaukee, WI, 2005.

<P>
<P>
IEC 61131-3, &ldquo;International Standard, Programmable Controllers &ndash; Part 3: Programming Languages&rdquo;, Edition 2.0, International Electrotechnical Commission, Geneva, Switzerland, 2003.

<P>
<P>

&ldquo;Logix5000 Controllers I/O and Tag Data&rdquo;, Publication 1756-PM004B-EN-P, Rockwell Automation, Inc., Milwaukee, WI, 2008.

<P>
<P>

&ldquo;Programming with STEP 7&rdquo;, Siemens AG, Nürnberg, Germany, 2006.

<P>
<P>

&ldquo;S7-200 Programmable Controller System Manual&rdquo;, Order Number 6ES7298-8FA24-8BH0, Edition 09/2007, Siemens AG, Nürnberg, Germany, 2007.

<P>
<P>

&ldquo;SLC 500 Family of Programmable Controllers Addressing Reference Manual&rdquo;, Publication 5000-6.4.23, Allen-Bradley Company, Inc., Milwaukee, WI, 1995.

<P>
<P>

&ldquo;SLC 500 Modular Hardware Style User Manual&rdquo;, Publication 1747-UM011E-EN-P, Rockwell Automation, Inc., Milwaukee, WI, 2004.

<P>
]

<P>
	</body>
</html>

